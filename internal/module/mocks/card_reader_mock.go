// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/iamvkosarev/learning-cards/internal/module.CardReader -o card_reader_mock.go -n CardReaderMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/iamvkosarev/learning-cards/internal/model"
)

// CardReaderMock implements mm_module.CardReader
type CardReaderMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetCard          func(ctx context.Context, cardId model.CardId) (cp1 *model.Card, err error)
	funcGetCardOrigin    string
	inspectFuncGetCard   func(ctx context.Context, cardId model.CardId)
	afterGetCardCounter  uint64
	beforeGetCardCounter uint64
	GetCardMock          mCardReaderMockGetCard

	funcListCards          func(ctx context.Context, groupId model.GroupId) (cpa1 []*model.Card, err error)
	funcListCardsOrigin    string
	inspectFuncListCards   func(ctx context.Context, groupId model.GroupId)
	afterListCardsCounter  uint64
	beforeListCardsCounter uint64
	ListCardsMock          mCardReaderMockListCards
}

// NewCardReaderMock returns a mock for mm_module.CardReader
func NewCardReaderMock(t minimock.Tester) *CardReaderMock {
	m := &CardReaderMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetCardMock = mCardReaderMockGetCard{mock: m}
	m.GetCardMock.callArgs = []*CardReaderMockGetCardParams{}

	m.ListCardsMock = mCardReaderMockListCards{mock: m}
	m.ListCardsMock.callArgs = []*CardReaderMockListCardsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCardReaderMockGetCard struct {
	optional           bool
	mock               *CardReaderMock
	defaultExpectation *CardReaderMockGetCardExpectation
	expectations       []*CardReaderMockGetCardExpectation

	callArgs []*CardReaderMockGetCardParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CardReaderMockGetCardExpectation specifies expectation struct of the CardReader.GetCard
type CardReaderMockGetCardExpectation struct {
	mock               *CardReaderMock
	params             *CardReaderMockGetCardParams
	paramPtrs          *CardReaderMockGetCardParamPtrs
	expectationOrigins CardReaderMockGetCardExpectationOrigins
	results            *CardReaderMockGetCardResults
	returnOrigin       string
	Counter            uint64
}

// CardReaderMockGetCardParams contains parameters of the CardReader.GetCard
type CardReaderMockGetCardParams struct {
	ctx    context.Context
	cardId model.CardId
}

// CardReaderMockGetCardParamPtrs contains pointers to parameters of the CardReader.GetCard
type CardReaderMockGetCardParamPtrs struct {
	ctx    *context.Context
	cardId *model.CardId
}

// CardReaderMockGetCardResults contains results of the CardReader.GetCard
type CardReaderMockGetCardResults struct {
	cp1 *model.Card
	err error
}

// CardReaderMockGetCardOrigins contains origins of expectations of the CardReader.GetCard
type CardReaderMockGetCardExpectationOrigins struct {
	origin       string
	originCtx    string
	originCardId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCard *mCardReaderMockGetCard) Optional() *mCardReaderMockGetCard {
	mmGetCard.optional = true
	return mmGetCard
}

// Expect sets up expected params for CardReader.GetCard
func (mmGetCard *mCardReaderMockGetCard) Expect(ctx context.Context, cardId model.CardId) *mCardReaderMockGetCard {
	if mmGetCard.mock.funcGetCard != nil {
		mmGetCard.mock.t.Fatalf("CardReaderMock.GetCard mock is already set by Set")
	}

	if mmGetCard.defaultExpectation == nil {
		mmGetCard.defaultExpectation = &CardReaderMockGetCardExpectation{}
	}

	if mmGetCard.defaultExpectation.paramPtrs != nil {
		mmGetCard.mock.t.Fatalf("CardReaderMock.GetCard mock is already set by ExpectParams functions")
	}

	mmGetCard.defaultExpectation.params = &CardReaderMockGetCardParams{ctx, cardId}
	mmGetCard.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCard.expectations {
		if minimock.Equal(e.params, mmGetCard.defaultExpectation.params) {
			mmGetCard.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCard.defaultExpectation.params)
		}
	}

	return mmGetCard
}

// ExpectCtxParam1 sets up expected param ctx for CardReader.GetCard
func (mmGetCard *mCardReaderMockGetCard) ExpectCtxParam1(ctx context.Context) *mCardReaderMockGetCard {
	if mmGetCard.mock.funcGetCard != nil {
		mmGetCard.mock.t.Fatalf("CardReaderMock.GetCard mock is already set by Set")
	}

	if mmGetCard.defaultExpectation == nil {
		mmGetCard.defaultExpectation = &CardReaderMockGetCardExpectation{}
	}

	if mmGetCard.defaultExpectation.params != nil {
		mmGetCard.mock.t.Fatalf("CardReaderMock.GetCard mock is already set by Expect")
	}

	if mmGetCard.defaultExpectation.paramPtrs == nil {
		mmGetCard.defaultExpectation.paramPtrs = &CardReaderMockGetCardParamPtrs{}
	}
	mmGetCard.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCard.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCard
}

// ExpectCardIdParam2 sets up expected param cardId for CardReader.GetCard
func (mmGetCard *mCardReaderMockGetCard) ExpectCardIdParam2(cardId model.CardId) *mCardReaderMockGetCard {
	if mmGetCard.mock.funcGetCard != nil {
		mmGetCard.mock.t.Fatalf("CardReaderMock.GetCard mock is already set by Set")
	}

	if mmGetCard.defaultExpectation == nil {
		mmGetCard.defaultExpectation = &CardReaderMockGetCardExpectation{}
	}

	if mmGetCard.defaultExpectation.params != nil {
		mmGetCard.mock.t.Fatalf("CardReaderMock.GetCard mock is already set by Expect")
	}

	if mmGetCard.defaultExpectation.paramPtrs == nil {
		mmGetCard.defaultExpectation.paramPtrs = &CardReaderMockGetCardParamPtrs{}
	}
	mmGetCard.defaultExpectation.paramPtrs.cardId = &cardId
	mmGetCard.defaultExpectation.expectationOrigins.originCardId = minimock.CallerInfo(1)

	return mmGetCard
}

// Inspect accepts an inspector function that has same arguments as the CardReader.GetCard
func (mmGetCard *mCardReaderMockGetCard) Inspect(f func(ctx context.Context, cardId model.CardId)) *mCardReaderMockGetCard {
	if mmGetCard.mock.inspectFuncGetCard != nil {
		mmGetCard.mock.t.Fatalf("Inspect function is already set for CardReaderMock.GetCard")
	}

	mmGetCard.mock.inspectFuncGetCard = f

	return mmGetCard
}

// Return sets up results that will be returned by CardReader.GetCard
func (mmGetCard *mCardReaderMockGetCard) Return(cp1 *model.Card, err error) *CardReaderMock {
	if mmGetCard.mock.funcGetCard != nil {
		mmGetCard.mock.t.Fatalf("CardReaderMock.GetCard mock is already set by Set")
	}

	if mmGetCard.defaultExpectation == nil {
		mmGetCard.defaultExpectation = &CardReaderMockGetCardExpectation{mock: mmGetCard.mock}
	}
	mmGetCard.defaultExpectation.results = &CardReaderMockGetCardResults{cp1, err}
	mmGetCard.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCard.mock
}

// Set uses given function f to mock the CardReader.GetCard method
func (mmGetCard *mCardReaderMockGetCard) Set(f func(ctx context.Context, cardId model.CardId) (cp1 *model.Card, err error)) *CardReaderMock {
	if mmGetCard.defaultExpectation != nil {
		mmGetCard.mock.t.Fatalf("Default expectation is already set for the CardReader.GetCard method")
	}

	if len(mmGetCard.expectations) > 0 {
		mmGetCard.mock.t.Fatalf("Some expectations are already set for the CardReader.GetCard method")
	}

	mmGetCard.mock.funcGetCard = f
	mmGetCard.mock.funcGetCardOrigin = minimock.CallerInfo(1)
	return mmGetCard.mock
}

// When sets expectation for the CardReader.GetCard which will trigger the result defined by the following
// Then helper
func (mmGetCard *mCardReaderMockGetCard) When(ctx context.Context, cardId model.CardId) *CardReaderMockGetCardExpectation {
	if mmGetCard.mock.funcGetCard != nil {
		mmGetCard.mock.t.Fatalf("CardReaderMock.GetCard mock is already set by Set")
	}

	expectation := &CardReaderMockGetCardExpectation{
		mock:               mmGetCard.mock,
		params:             &CardReaderMockGetCardParams{ctx, cardId},
		expectationOrigins: CardReaderMockGetCardExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCard.expectations = append(mmGetCard.expectations, expectation)
	return expectation
}

// Then sets up CardReader.GetCard return parameters for the expectation previously defined by the When method
func (e *CardReaderMockGetCardExpectation) Then(cp1 *model.Card, err error) *CardReaderMock {
	e.results = &CardReaderMockGetCardResults{cp1, err}
	return e.mock
}

// Times sets number of times CardReader.GetCard should be invoked
func (mmGetCard *mCardReaderMockGetCard) Times(n uint64) *mCardReaderMockGetCard {
	if n == 0 {
		mmGetCard.mock.t.Fatalf("Times of CardReaderMock.GetCard mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCard.expectedInvocations, n)
	mmGetCard.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCard
}

func (mmGetCard *mCardReaderMockGetCard) invocationsDone() bool {
	if len(mmGetCard.expectations) == 0 && mmGetCard.defaultExpectation == nil && mmGetCard.mock.funcGetCard == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCard.mock.afterGetCardCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCard.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCard implements mm_module.CardReader
func (mmGetCard *CardReaderMock) GetCard(ctx context.Context, cardId model.CardId) (cp1 *model.Card, err error) {
	mm_atomic.AddUint64(&mmGetCard.beforeGetCardCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCard.afterGetCardCounter, 1)

	mmGetCard.t.Helper()

	if mmGetCard.inspectFuncGetCard != nil {
		mmGetCard.inspectFuncGetCard(ctx, cardId)
	}

	mm_params := CardReaderMockGetCardParams{ctx, cardId}

	// Record call args
	mmGetCard.GetCardMock.mutex.Lock()
	mmGetCard.GetCardMock.callArgs = append(mmGetCard.GetCardMock.callArgs, &mm_params)
	mmGetCard.GetCardMock.mutex.Unlock()

	for _, e := range mmGetCard.GetCardMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetCard.GetCardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCard.GetCardMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCard.GetCardMock.defaultExpectation.params
		mm_want_ptrs := mmGetCard.GetCardMock.defaultExpectation.paramPtrs

		mm_got := CardReaderMockGetCardParams{ctx, cardId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCard.t.Errorf("CardReaderMock.GetCard got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCard.GetCardMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cardId != nil && !minimock.Equal(*mm_want_ptrs.cardId, mm_got.cardId) {
				mmGetCard.t.Errorf("CardReaderMock.GetCard got unexpected parameter cardId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCard.GetCardMock.defaultExpectation.expectationOrigins.originCardId, *mm_want_ptrs.cardId, mm_got.cardId, minimock.Diff(*mm_want_ptrs.cardId, mm_got.cardId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCard.t.Errorf("CardReaderMock.GetCard got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCard.GetCardMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCard.GetCardMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCard.t.Fatal("No results are set for the CardReaderMock.GetCard")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetCard.funcGetCard != nil {
		return mmGetCard.funcGetCard(ctx, cardId)
	}
	mmGetCard.t.Fatalf("Unexpected call to CardReaderMock.GetCard. %v %v", ctx, cardId)
	return
}

// GetCardAfterCounter returns a count of finished CardReaderMock.GetCard invocations
func (mmGetCard *CardReaderMock) GetCardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCard.afterGetCardCounter)
}

// GetCardBeforeCounter returns a count of CardReaderMock.GetCard invocations
func (mmGetCard *CardReaderMock) GetCardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCard.beforeGetCardCounter)
}

// Calls returns a list of arguments used in each call to CardReaderMock.GetCard.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCard *mCardReaderMockGetCard) Calls() []*CardReaderMockGetCardParams {
	mmGetCard.mutex.RLock()

	argCopy := make([]*CardReaderMockGetCardParams, len(mmGetCard.callArgs))
	copy(argCopy, mmGetCard.callArgs)

	mmGetCard.mutex.RUnlock()

	return argCopy
}

// MinimockGetCardDone returns true if the count of the GetCard invocations corresponds
// the number of defined expectations
func (m *CardReaderMock) MinimockGetCardDone() bool {
	if m.GetCardMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCardMock.invocationsDone()
}

// MinimockGetCardInspect logs each unmet expectation
func (m *CardReaderMock) MinimockGetCardInspect() {
	for _, e := range m.GetCardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CardReaderMock.GetCard at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCardCounter := mm_atomic.LoadUint64(&m.afterGetCardCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCardMock.defaultExpectation != nil && afterGetCardCounter < 1 {
		if m.GetCardMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CardReaderMock.GetCard at\n%s", m.GetCardMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CardReaderMock.GetCard at\n%s with params: %#v", m.GetCardMock.defaultExpectation.expectationOrigins.origin, *m.GetCardMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCard != nil && afterGetCardCounter < 1 {
		m.t.Errorf("Expected call to CardReaderMock.GetCard at\n%s", m.funcGetCardOrigin)
	}

	if !m.GetCardMock.invocationsDone() && afterGetCardCounter > 0 {
		m.t.Errorf("Expected %d calls to CardReaderMock.GetCard at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCardMock.expectedInvocations), m.GetCardMock.expectedInvocationsOrigin, afterGetCardCounter)
	}
}

type mCardReaderMockListCards struct {
	optional           bool
	mock               *CardReaderMock
	defaultExpectation *CardReaderMockListCardsExpectation
	expectations       []*CardReaderMockListCardsExpectation

	callArgs []*CardReaderMockListCardsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CardReaderMockListCardsExpectation specifies expectation struct of the CardReader.ListCards
type CardReaderMockListCardsExpectation struct {
	mock               *CardReaderMock
	params             *CardReaderMockListCardsParams
	paramPtrs          *CardReaderMockListCardsParamPtrs
	expectationOrigins CardReaderMockListCardsExpectationOrigins
	results            *CardReaderMockListCardsResults
	returnOrigin       string
	Counter            uint64
}

// CardReaderMockListCardsParams contains parameters of the CardReader.ListCards
type CardReaderMockListCardsParams struct {
	ctx     context.Context
	groupId model.GroupId
}

// CardReaderMockListCardsParamPtrs contains pointers to parameters of the CardReader.ListCards
type CardReaderMockListCardsParamPtrs struct {
	ctx     *context.Context
	groupId *model.GroupId
}

// CardReaderMockListCardsResults contains results of the CardReader.ListCards
type CardReaderMockListCardsResults struct {
	cpa1 []*model.Card
	err  error
}

// CardReaderMockListCardsOrigins contains origins of expectations of the CardReader.ListCards
type CardReaderMockListCardsExpectationOrigins struct {
	origin        string
	originCtx     string
	originGroupId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCards *mCardReaderMockListCards) Optional() *mCardReaderMockListCards {
	mmListCards.optional = true
	return mmListCards
}

// Expect sets up expected params for CardReader.ListCards
func (mmListCards *mCardReaderMockListCards) Expect(ctx context.Context, groupId model.GroupId) *mCardReaderMockListCards {
	if mmListCards.mock.funcListCards != nil {
		mmListCards.mock.t.Fatalf("CardReaderMock.ListCards mock is already set by Set")
	}

	if mmListCards.defaultExpectation == nil {
		mmListCards.defaultExpectation = &CardReaderMockListCardsExpectation{}
	}

	if mmListCards.defaultExpectation.paramPtrs != nil {
		mmListCards.mock.t.Fatalf("CardReaderMock.ListCards mock is already set by ExpectParams functions")
	}

	mmListCards.defaultExpectation.params = &CardReaderMockListCardsParams{ctx, groupId}
	mmListCards.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListCards.expectations {
		if minimock.Equal(e.params, mmListCards.defaultExpectation.params) {
			mmListCards.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCards.defaultExpectation.params)
		}
	}

	return mmListCards
}

// ExpectCtxParam1 sets up expected param ctx for CardReader.ListCards
func (mmListCards *mCardReaderMockListCards) ExpectCtxParam1(ctx context.Context) *mCardReaderMockListCards {
	if mmListCards.mock.funcListCards != nil {
		mmListCards.mock.t.Fatalf("CardReaderMock.ListCards mock is already set by Set")
	}

	if mmListCards.defaultExpectation == nil {
		mmListCards.defaultExpectation = &CardReaderMockListCardsExpectation{}
	}

	if mmListCards.defaultExpectation.params != nil {
		mmListCards.mock.t.Fatalf("CardReaderMock.ListCards mock is already set by Expect")
	}

	if mmListCards.defaultExpectation.paramPtrs == nil {
		mmListCards.defaultExpectation.paramPtrs = &CardReaderMockListCardsParamPtrs{}
	}
	mmListCards.defaultExpectation.paramPtrs.ctx = &ctx
	mmListCards.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListCards
}

// ExpectGroupIdParam2 sets up expected param groupId for CardReader.ListCards
func (mmListCards *mCardReaderMockListCards) ExpectGroupIdParam2(groupId model.GroupId) *mCardReaderMockListCards {
	if mmListCards.mock.funcListCards != nil {
		mmListCards.mock.t.Fatalf("CardReaderMock.ListCards mock is already set by Set")
	}

	if mmListCards.defaultExpectation == nil {
		mmListCards.defaultExpectation = &CardReaderMockListCardsExpectation{}
	}

	if mmListCards.defaultExpectation.params != nil {
		mmListCards.mock.t.Fatalf("CardReaderMock.ListCards mock is already set by Expect")
	}

	if mmListCards.defaultExpectation.paramPtrs == nil {
		mmListCards.defaultExpectation.paramPtrs = &CardReaderMockListCardsParamPtrs{}
	}
	mmListCards.defaultExpectation.paramPtrs.groupId = &groupId
	mmListCards.defaultExpectation.expectationOrigins.originGroupId = minimock.CallerInfo(1)

	return mmListCards
}

// Inspect accepts an inspector function that has same arguments as the CardReader.ListCards
func (mmListCards *mCardReaderMockListCards) Inspect(f func(ctx context.Context, groupId model.GroupId)) *mCardReaderMockListCards {
	if mmListCards.mock.inspectFuncListCards != nil {
		mmListCards.mock.t.Fatalf("Inspect function is already set for CardReaderMock.ListCards")
	}

	mmListCards.mock.inspectFuncListCards = f

	return mmListCards
}

// Return sets up results that will be returned by CardReader.ListCards
func (mmListCards *mCardReaderMockListCards) Return(cpa1 []*model.Card, err error) *CardReaderMock {
	if mmListCards.mock.funcListCards != nil {
		mmListCards.mock.t.Fatalf("CardReaderMock.ListCards mock is already set by Set")
	}

	if mmListCards.defaultExpectation == nil {
		mmListCards.defaultExpectation = &CardReaderMockListCardsExpectation{mock: mmListCards.mock}
	}
	mmListCards.defaultExpectation.results = &CardReaderMockListCardsResults{cpa1, err}
	mmListCards.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListCards.mock
}

// Set uses given function f to mock the CardReader.ListCards method
func (mmListCards *mCardReaderMockListCards) Set(f func(ctx context.Context, groupId model.GroupId) (cpa1 []*model.Card, err error)) *CardReaderMock {
	if mmListCards.defaultExpectation != nil {
		mmListCards.mock.t.Fatalf("Default expectation is already set for the CardReader.ListCards method")
	}

	if len(mmListCards.expectations) > 0 {
		mmListCards.mock.t.Fatalf("Some expectations are already set for the CardReader.ListCards method")
	}

	mmListCards.mock.funcListCards = f
	mmListCards.mock.funcListCardsOrigin = minimock.CallerInfo(1)
	return mmListCards.mock
}

// When sets expectation for the CardReader.ListCards which will trigger the result defined by the following
// Then helper
func (mmListCards *mCardReaderMockListCards) When(ctx context.Context, groupId model.GroupId) *CardReaderMockListCardsExpectation {
	if mmListCards.mock.funcListCards != nil {
		mmListCards.mock.t.Fatalf("CardReaderMock.ListCards mock is already set by Set")
	}

	expectation := &CardReaderMockListCardsExpectation{
		mock:               mmListCards.mock,
		params:             &CardReaderMockListCardsParams{ctx, groupId},
		expectationOrigins: CardReaderMockListCardsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListCards.expectations = append(mmListCards.expectations, expectation)
	return expectation
}

// Then sets up CardReader.ListCards return parameters for the expectation previously defined by the When method
func (e *CardReaderMockListCardsExpectation) Then(cpa1 []*model.Card, err error) *CardReaderMock {
	e.results = &CardReaderMockListCardsResults{cpa1, err}
	return e.mock
}

// Times sets number of times CardReader.ListCards should be invoked
func (mmListCards *mCardReaderMockListCards) Times(n uint64) *mCardReaderMockListCards {
	if n == 0 {
		mmListCards.mock.t.Fatalf("Times of CardReaderMock.ListCards mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCards.expectedInvocations, n)
	mmListCards.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListCards
}

func (mmListCards *mCardReaderMockListCards) invocationsDone() bool {
	if len(mmListCards.expectations) == 0 && mmListCards.defaultExpectation == nil && mmListCards.mock.funcListCards == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCards.mock.afterListCardsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCards.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCards implements mm_module.CardReader
func (mmListCards *CardReaderMock) ListCards(ctx context.Context, groupId model.GroupId) (cpa1 []*model.Card, err error) {
	mm_atomic.AddUint64(&mmListCards.beforeListCardsCounter, 1)
	defer mm_atomic.AddUint64(&mmListCards.afterListCardsCounter, 1)

	mmListCards.t.Helper()

	if mmListCards.inspectFuncListCards != nil {
		mmListCards.inspectFuncListCards(ctx, groupId)
	}

	mm_params := CardReaderMockListCardsParams{ctx, groupId}

	// Record call args
	mmListCards.ListCardsMock.mutex.Lock()
	mmListCards.ListCardsMock.callArgs = append(mmListCards.ListCardsMock.callArgs, &mm_params)
	mmListCards.ListCardsMock.mutex.Unlock()

	for _, e := range mmListCards.ListCardsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmListCards.ListCardsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCards.ListCardsMock.defaultExpectation.Counter, 1)
		mm_want := mmListCards.ListCardsMock.defaultExpectation.params
		mm_want_ptrs := mmListCards.ListCardsMock.defaultExpectation.paramPtrs

		mm_got := CardReaderMockListCardsParams{ctx, groupId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCards.t.Errorf("CardReaderMock.ListCards got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCards.ListCardsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.groupId != nil && !minimock.Equal(*mm_want_ptrs.groupId, mm_got.groupId) {
				mmListCards.t.Errorf("CardReaderMock.ListCards got unexpected parameter groupId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCards.ListCardsMock.defaultExpectation.expectationOrigins.originGroupId, *mm_want_ptrs.groupId, mm_got.groupId, minimock.Diff(*mm_want_ptrs.groupId, mm_got.groupId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCards.t.Errorf("CardReaderMock.ListCards got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListCards.ListCardsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCards.ListCardsMock.defaultExpectation.results
		if mm_results == nil {
			mmListCards.t.Fatal("No results are set for the CardReaderMock.ListCards")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmListCards.funcListCards != nil {
		return mmListCards.funcListCards(ctx, groupId)
	}
	mmListCards.t.Fatalf("Unexpected call to CardReaderMock.ListCards. %v %v", ctx, groupId)
	return
}

// ListCardsAfterCounter returns a count of finished CardReaderMock.ListCards invocations
func (mmListCards *CardReaderMock) ListCardsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCards.afterListCardsCounter)
}

// ListCardsBeforeCounter returns a count of CardReaderMock.ListCards invocations
func (mmListCards *CardReaderMock) ListCardsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCards.beforeListCardsCounter)
}

// Calls returns a list of arguments used in each call to CardReaderMock.ListCards.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCards *mCardReaderMockListCards) Calls() []*CardReaderMockListCardsParams {
	mmListCards.mutex.RLock()

	argCopy := make([]*CardReaderMockListCardsParams, len(mmListCards.callArgs))
	copy(argCopy, mmListCards.callArgs)

	mmListCards.mutex.RUnlock()

	return argCopy
}

// MinimockListCardsDone returns true if the count of the ListCards invocations corresponds
// the number of defined expectations
func (m *CardReaderMock) MinimockListCardsDone() bool {
	if m.ListCardsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCardsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCardsMock.invocationsDone()
}

// MinimockListCardsInspect logs each unmet expectation
func (m *CardReaderMock) MinimockListCardsInspect() {
	for _, e := range m.ListCardsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CardReaderMock.ListCards at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCardsCounter := mm_atomic.LoadUint64(&m.afterListCardsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCardsMock.defaultExpectation != nil && afterListCardsCounter < 1 {
		if m.ListCardsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CardReaderMock.ListCards at\n%s", m.ListCardsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CardReaderMock.ListCards at\n%s with params: %#v", m.ListCardsMock.defaultExpectation.expectationOrigins.origin, *m.ListCardsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCards != nil && afterListCardsCounter < 1 {
		m.t.Errorf("Expected call to CardReaderMock.ListCards at\n%s", m.funcListCardsOrigin)
	}

	if !m.ListCardsMock.invocationsDone() && afterListCardsCounter > 0 {
		m.t.Errorf("Expected %d calls to CardReaderMock.ListCards at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListCardsMock.expectedInvocations), m.ListCardsMock.expectedInvocationsOrigin, afterListCardsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CardReaderMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetCardInspect()

			m.MinimockListCardsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CardReaderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CardReaderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetCardDone() &&
		m.MinimockListCardsDone()
}
