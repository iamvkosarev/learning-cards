// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/iamvkosarev/learning-cards/internal/module.ReviewWriter -o review_writer_mock.go -n ReviewWriterMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/iamvkosarev/learning-cards/internal/model"
)

// ReviewWriterMock implements mm_module.ReviewWriter
type ReviewWriterMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddCardsReviews          func(ctx context.Context, user model.UserId, group model.GroupId, cardsProgress []model.CardReview) (err error)
	funcAddCardsReviewsOrigin    string
	inspectFuncAddCardsReviews   func(ctx context.Context, user model.UserId, group model.GroupId, cardsProgress []model.CardReview)
	afterAddCardsReviewsCounter  uint64
	beforeAddCardsReviewsCounter uint64
	AddCardsReviewsMock          mReviewWriterMockAddCardsReviews

	funcDeleteNotUsedReviews          func(ctx context.Context, userId model.UserId, groupId model.GroupId) (err error)
	funcDeleteNotUsedReviewsOrigin    string
	inspectFuncDeleteNotUsedReviews   func(ctx context.Context, userId model.UserId, groupId model.GroupId)
	afterDeleteNotUsedReviewsCounter  uint64
	beforeDeleteNotUsedReviewsCounter uint64
	DeleteNotUsedReviewsMock          mReviewWriterMockDeleteNotUsedReviews
}

// NewReviewWriterMock returns a mock for mm_module.ReviewWriter
func NewReviewWriterMock(t minimock.Tester) *ReviewWriterMock {
	m := &ReviewWriterMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddCardsReviewsMock = mReviewWriterMockAddCardsReviews{mock: m}
	m.AddCardsReviewsMock.callArgs = []*ReviewWriterMockAddCardsReviewsParams{}

	m.DeleteNotUsedReviewsMock = mReviewWriterMockDeleteNotUsedReviews{mock: m}
	m.DeleteNotUsedReviewsMock.callArgs = []*ReviewWriterMockDeleteNotUsedReviewsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mReviewWriterMockAddCardsReviews struct {
	optional           bool
	mock               *ReviewWriterMock
	defaultExpectation *ReviewWriterMockAddCardsReviewsExpectation
	expectations       []*ReviewWriterMockAddCardsReviewsExpectation

	callArgs []*ReviewWriterMockAddCardsReviewsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReviewWriterMockAddCardsReviewsExpectation specifies expectation struct of the ReviewWriter.AddCardsReviews
type ReviewWriterMockAddCardsReviewsExpectation struct {
	mock               *ReviewWriterMock
	params             *ReviewWriterMockAddCardsReviewsParams
	paramPtrs          *ReviewWriterMockAddCardsReviewsParamPtrs
	expectationOrigins ReviewWriterMockAddCardsReviewsExpectationOrigins
	results            *ReviewWriterMockAddCardsReviewsResults
	returnOrigin       string
	Counter            uint64
}

// ReviewWriterMockAddCardsReviewsParams contains parameters of the ReviewWriter.AddCardsReviews
type ReviewWriterMockAddCardsReviewsParams struct {
	ctx           context.Context
	user          model.UserId
	group         model.GroupId
	cardsProgress []model.CardReview
}

// ReviewWriterMockAddCardsReviewsParamPtrs contains pointers to parameters of the ReviewWriter.AddCardsReviews
type ReviewWriterMockAddCardsReviewsParamPtrs struct {
	ctx           *context.Context
	user          *model.UserId
	group         *model.GroupId
	cardsProgress *[]model.CardReview
}

// ReviewWriterMockAddCardsReviewsResults contains results of the ReviewWriter.AddCardsReviews
type ReviewWriterMockAddCardsReviewsResults struct {
	err error
}

// ReviewWriterMockAddCardsReviewsOrigins contains origins of expectations of the ReviewWriter.AddCardsReviews
type ReviewWriterMockAddCardsReviewsExpectationOrigins struct {
	origin              string
	originCtx           string
	originUser          string
	originGroup         string
	originCardsProgress string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddCardsReviews *mReviewWriterMockAddCardsReviews) Optional() *mReviewWriterMockAddCardsReviews {
	mmAddCardsReviews.optional = true
	return mmAddCardsReviews
}

// Expect sets up expected params for ReviewWriter.AddCardsReviews
func (mmAddCardsReviews *mReviewWriterMockAddCardsReviews) Expect(ctx context.Context, user model.UserId, group model.GroupId, cardsProgress []model.CardReview) *mReviewWriterMockAddCardsReviews {
	if mmAddCardsReviews.mock.funcAddCardsReviews != nil {
		mmAddCardsReviews.mock.t.Fatalf("ReviewWriterMock.AddCardsReviews mock is already set by Set")
	}

	if mmAddCardsReviews.defaultExpectation == nil {
		mmAddCardsReviews.defaultExpectation = &ReviewWriterMockAddCardsReviewsExpectation{}
	}

	if mmAddCardsReviews.defaultExpectation.paramPtrs != nil {
		mmAddCardsReviews.mock.t.Fatalf("ReviewWriterMock.AddCardsReviews mock is already set by ExpectParams functions")
	}

	mmAddCardsReviews.defaultExpectation.params = &ReviewWriterMockAddCardsReviewsParams{ctx, user, group, cardsProgress}
	mmAddCardsReviews.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddCardsReviews.expectations {
		if minimock.Equal(e.params, mmAddCardsReviews.defaultExpectation.params) {
			mmAddCardsReviews.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddCardsReviews.defaultExpectation.params)
		}
	}

	return mmAddCardsReviews
}

// ExpectCtxParam1 sets up expected param ctx for ReviewWriter.AddCardsReviews
func (mmAddCardsReviews *mReviewWriterMockAddCardsReviews) ExpectCtxParam1(ctx context.Context) *mReviewWriterMockAddCardsReviews {
	if mmAddCardsReviews.mock.funcAddCardsReviews != nil {
		mmAddCardsReviews.mock.t.Fatalf("ReviewWriterMock.AddCardsReviews mock is already set by Set")
	}

	if mmAddCardsReviews.defaultExpectation == nil {
		mmAddCardsReviews.defaultExpectation = &ReviewWriterMockAddCardsReviewsExpectation{}
	}

	if mmAddCardsReviews.defaultExpectation.params != nil {
		mmAddCardsReviews.mock.t.Fatalf("ReviewWriterMock.AddCardsReviews mock is already set by Expect")
	}

	if mmAddCardsReviews.defaultExpectation.paramPtrs == nil {
		mmAddCardsReviews.defaultExpectation.paramPtrs = &ReviewWriterMockAddCardsReviewsParamPtrs{}
	}
	mmAddCardsReviews.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddCardsReviews.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddCardsReviews
}

// ExpectUserParam2 sets up expected param user for ReviewWriter.AddCardsReviews
func (mmAddCardsReviews *mReviewWriterMockAddCardsReviews) ExpectUserParam2(user model.UserId) *mReviewWriterMockAddCardsReviews {
	if mmAddCardsReviews.mock.funcAddCardsReviews != nil {
		mmAddCardsReviews.mock.t.Fatalf("ReviewWriterMock.AddCardsReviews mock is already set by Set")
	}

	if mmAddCardsReviews.defaultExpectation == nil {
		mmAddCardsReviews.defaultExpectation = &ReviewWriterMockAddCardsReviewsExpectation{}
	}

	if mmAddCardsReviews.defaultExpectation.params != nil {
		mmAddCardsReviews.mock.t.Fatalf("ReviewWriterMock.AddCardsReviews mock is already set by Expect")
	}

	if mmAddCardsReviews.defaultExpectation.paramPtrs == nil {
		mmAddCardsReviews.defaultExpectation.paramPtrs = &ReviewWriterMockAddCardsReviewsParamPtrs{}
	}
	mmAddCardsReviews.defaultExpectation.paramPtrs.user = &user
	mmAddCardsReviews.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmAddCardsReviews
}

// ExpectGroupParam3 sets up expected param group for ReviewWriter.AddCardsReviews
func (mmAddCardsReviews *mReviewWriterMockAddCardsReviews) ExpectGroupParam3(group model.GroupId) *mReviewWriterMockAddCardsReviews {
	if mmAddCardsReviews.mock.funcAddCardsReviews != nil {
		mmAddCardsReviews.mock.t.Fatalf("ReviewWriterMock.AddCardsReviews mock is already set by Set")
	}

	if mmAddCardsReviews.defaultExpectation == nil {
		mmAddCardsReviews.defaultExpectation = &ReviewWriterMockAddCardsReviewsExpectation{}
	}

	if mmAddCardsReviews.defaultExpectation.params != nil {
		mmAddCardsReviews.mock.t.Fatalf("ReviewWriterMock.AddCardsReviews mock is already set by Expect")
	}

	if mmAddCardsReviews.defaultExpectation.paramPtrs == nil {
		mmAddCardsReviews.defaultExpectation.paramPtrs = &ReviewWriterMockAddCardsReviewsParamPtrs{}
	}
	mmAddCardsReviews.defaultExpectation.paramPtrs.group = &group
	mmAddCardsReviews.defaultExpectation.expectationOrigins.originGroup = minimock.CallerInfo(1)

	return mmAddCardsReviews
}

// ExpectCardsProgressParam4 sets up expected param cardsProgress for ReviewWriter.AddCardsReviews
func (mmAddCardsReviews *mReviewWriterMockAddCardsReviews) ExpectCardsProgressParam4(cardsProgress []model.CardReview) *mReviewWriterMockAddCardsReviews {
	if mmAddCardsReviews.mock.funcAddCardsReviews != nil {
		mmAddCardsReviews.mock.t.Fatalf("ReviewWriterMock.AddCardsReviews mock is already set by Set")
	}

	if mmAddCardsReviews.defaultExpectation == nil {
		mmAddCardsReviews.defaultExpectation = &ReviewWriterMockAddCardsReviewsExpectation{}
	}

	if mmAddCardsReviews.defaultExpectation.params != nil {
		mmAddCardsReviews.mock.t.Fatalf("ReviewWriterMock.AddCardsReviews mock is already set by Expect")
	}

	if mmAddCardsReviews.defaultExpectation.paramPtrs == nil {
		mmAddCardsReviews.defaultExpectation.paramPtrs = &ReviewWriterMockAddCardsReviewsParamPtrs{}
	}
	mmAddCardsReviews.defaultExpectation.paramPtrs.cardsProgress = &cardsProgress
	mmAddCardsReviews.defaultExpectation.expectationOrigins.originCardsProgress = minimock.CallerInfo(1)

	return mmAddCardsReviews
}

// Inspect accepts an inspector function that has same arguments as the ReviewWriter.AddCardsReviews
func (mmAddCardsReviews *mReviewWriterMockAddCardsReviews) Inspect(f func(ctx context.Context, user model.UserId, group model.GroupId, cardsProgress []model.CardReview)) *mReviewWriterMockAddCardsReviews {
	if mmAddCardsReviews.mock.inspectFuncAddCardsReviews != nil {
		mmAddCardsReviews.mock.t.Fatalf("Inspect function is already set for ReviewWriterMock.AddCardsReviews")
	}

	mmAddCardsReviews.mock.inspectFuncAddCardsReviews = f

	return mmAddCardsReviews
}

// Return sets up results that will be returned by ReviewWriter.AddCardsReviews
func (mmAddCardsReviews *mReviewWriterMockAddCardsReviews) Return(err error) *ReviewWriterMock {
	if mmAddCardsReviews.mock.funcAddCardsReviews != nil {
		mmAddCardsReviews.mock.t.Fatalf("ReviewWriterMock.AddCardsReviews mock is already set by Set")
	}

	if mmAddCardsReviews.defaultExpectation == nil {
		mmAddCardsReviews.defaultExpectation = &ReviewWriterMockAddCardsReviewsExpectation{mock: mmAddCardsReviews.mock}
	}
	mmAddCardsReviews.defaultExpectation.results = &ReviewWriterMockAddCardsReviewsResults{err}
	mmAddCardsReviews.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddCardsReviews.mock
}

// Set uses given function f to mock the ReviewWriter.AddCardsReviews method
func (mmAddCardsReviews *mReviewWriterMockAddCardsReviews) Set(f func(ctx context.Context, user model.UserId, group model.GroupId, cardsProgress []model.CardReview) (err error)) *ReviewWriterMock {
	if mmAddCardsReviews.defaultExpectation != nil {
		mmAddCardsReviews.mock.t.Fatalf("Default expectation is already set for the ReviewWriter.AddCardsReviews method")
	}

	if len(mmAddCardsReviews.expectations) > 0 {
		mmAddCardsReviews.mock.t.Fatalf("Some expectations are already set for the ReviewWriter.AddCardsReviews method")
	}

	mmAddCardsReviews.mock.funcAddCardsReviews = f
	mmAddCardsReviews.mock.funcAddCardsReviewsOrigin = minimock.CallerInfo(1)
	return mmAddCardsReviews.mock
}

// When sets expectation for the ReviewWriter.AddCardsReviews which will trigger the result defined by the following
// Then helper
func (mmAddCardsReviews *mReviewWriterMockAddCardsReviews) When(ctx context.Context, user model.UserId, group model.GroupId, cardsProgress []model.CardReview) *ReviewWriterMockAddCardsReviewsExpectation {
	if mmAddCardsReviews.mock.funcAddCardsReviews != nil {
		mmAddCardsReviews.mock.t.Fatalf("ReviewWriterMock.AddCardsReviews mock is already set by Set")
	}

	expectation := &ReviewWriterMockAddCardsReviewsExpectation{
		mock:               mmAddCardsReviews.mock,
		params:             &ReviewWriterMockAddCardsReviewsParams{ctx, user, group, cardsProgress},
		expectationOrigins: ReviewWriterMockAddCardsReviewsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddCardsReviews.expectations = append(mmAddCardsReviews.expectations, expectation)
	return expectation
}

// Then sets up ReviewWriter.AddCardsReviews return parameters for the expectation previously defined by the When method
func (e *ReviewWriterMockAddCardsReviewsExpectation) Then(err error) *ReviewWriterMock {
	e.results = &ReviewWriterMockAddCardsReviewsResults{err}
	return e.mock
}

// Times sets number of times ReviewWriter.AddCardsReviews should be invoked
func (mmAddCardsReviews *mReviewWriterMockAddCardsReviews) Times(n uint64) *mReviewWriterMockAddCardsReviews {
	if n == 0 {
		mmAddCardsReviews.mock.t.Fatalf("Times of ReviewWriterMock.AddCardsReviews mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddCardsReviews.expectedInvocations, n)
	mmAddCardsReviews.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddCardsReviews
}

func (mmAddCardsReviews *mReviewWriterMockAddCardsReviews) invocationsDone() bool {
	if len(mmAddCardsReviews.expectations) == 0 && mmAddCardsReviews.defaultExpectation == nil && mmAddCardsReviews.mock.funcAddCardsReviews == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddCardsReviews.mock.afterAddCardsReviewsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddCardsReviews.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddCardsReviews implements mm_module.ReviewWriter
func (mmAddCardsReviews *ReviewWriterMock) AddCardsReviews(ctx context.Context, user model.UserId, group model.GroupId, cardsProgress []model.CardReview) (err error) {
	mm_atomic.AddUint64(&mmAddCardsReviews.beforeAddCardsReviewsCounter, 1)
	defer mm_atomic.AddUint64(&mmAddCardsReviews.afterAddCardsReviewsCounter, 1)

	mmAddCardsReviews.t.Helper()

	if mmAddCardsReviews.inspectFuncAddCardsReviews != nil {
		mmAddCardsReviews.inspectFuncAddCardsReviews(ctx, user, group, cardsProgress)
	}

	mm_params := ReviewWriterMockAddCardsReviewsParams{ctx, user, group, cardsProgress}

	// Record call args
	mmAddCardsReviews.AddCardsReviewsMock.mutex.Lock()
	mmAddCardsReviews.AddCardsReviewsMock.callArgs = append(mmAddCardsReviews.AddCardsReviewsMock.callArgs, &mm_params)
	mmAddCardsReviews.AddCardsReviewsMock.mutex.Unlock()

	for _, e := range mmAddCardsReviews.AddCardsReviewsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddCardsReviews.AddCardsReviewsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddCardsReviews.AddCardsReviewsMock.defaultExpectation.Counter, 1)
		mm_want := mmAddCardsReviews.AddCardsReviewsMock.defaultExpectation.params
		mm_want_ptrs := mmAddCardsReviews.AddCardsReviewsMock.defaultExpectation.paramPtrs

		mm_got := ReviewWriterMockAddCardsReviewsParams{ctx, user, group, cardsProgress}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddCardsReviews.t.Errorf("ReviewWriterMock.AddCardsReviews got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCardsReviews.AddCardsReviewsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmAddCardsReviews.t.Errorf("ReviewWriterMock.AddCardsReviews got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCardsReviews.AddCardsReviewsMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

			if mm_want_ptrs.group != nil && !minimock.Equal(*mm_want_ptrs.group, mm_got.group) {
				mmAddCardsReviews.t.Errorf("ReviewWriterMock.AddCardsReviews got unexpected parameter group, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCardsReviews.AddCardsReviewsMock.defaultExpectation.expectationOrigins.originGroup, *mm_want_ptrs.group, mm_got.group, minimock.Diff(*mm_want_ptrs.group, mm_got.group))
			}

			if mm_want_ptrs.cardsProgress != nil && !minimock.Equal(*mm_want_ptrs.cardsProgress, mm_got.cardsProgress) {
				mmAddCardsReviews.t.Errorf("ReviewWriterMock.AddCardsReviews got unexpected parameter cardsProgress, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCardsReviews.AddCardsReviewsMock.defaultExpectation.expectationOrigins.originCardsProgress, *mm_want_ptrs.cardsProgress, mm_got.cardsProgress, minimock.Diff(*mm_want_ptrs.cardsProgress, mm_got.cardsProgress))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddCardsReviews.t.Errorf("ReviewWriterMock.AddCardsReviews got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddCardsReviews.AddCardsReviewsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddCardsReviews.AddCardsReviewsMock.defaultExpectation.results
		if mm_results == nil {
			mmAddCardsReviews.t.Fatal("No results are set for the ReviewWriterMock.AddCardsReviews")
		}
		return (*mm_results).err
	}
	if mmAddCardsReviews.funcAddCardsReviews != nil {
		return mmAddCardsReviews.funcAddCardsReviews(ctx, user, group, cardsProgress)
	}
	mmAddCardsReviews.t.Fatalf("Unexpected call to ReviewWriterMock.AddCardsReviews. %v %v %v %v", ctx, user, group, cardsProgress)
	return
}

// AddCardsReviewsAfterCounter returns a count of finished ReviewWriterMock.AddCardsReviews invocations
func (mmAddCardsReviews *ReviewWriterMock) AddCardsReviewsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCardsReviews.afterAddCardsReviewsCounter)
}

// AddCardsReviewsBeforeCounter returns a count of ReviewWriterMock.AddCardsReviews invocations
func (mmAddCardsReviews *ReviewWriterMock) AddCardsReviewsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCardsReviews.beforeAddCardsReviewsCounter)
}

// Calls returns a list of arguments used in each call to ReviewWriterMock.AddCardsReviews.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddCardsReviews *mReviewWriterMockAddCardsReviews) Calls() []*ReviewWriterMockAddCardsReviewsParams {
	mmAddCardsReviews.mutex.RLock()

	argCopy := make([]*ReviewWriterMockAddCardsReviewsParams, len(mmAddCardsReviews.callArgs))
	copy(argCopy, mmAddCardsReviews.callArgs)

	mmAddCardsReviews.mutex.RUnlock()

	return argCopy
}

// MinimockAddCardsReviewsDone returns true if the count of the AddCardsReviews invocations corresponds
// the number of defined expectations
func (m *ReviewWriterMock) MinimockAddCardsReviewsDone() bool {
	if m.AddCardsReviewsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddCardsReviewsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddCardsReviewsMock.invocationsDone()
}

// MinimockAddCardsReviewsInspect logs each unmet expectation
func (m *ReviewWriterMock) MinimockAddCardsReviewsInspect() {
	for _, e := range m.AddCardsReviewsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReviewWriterMock.AddCardsReviews at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddCardsReviewsCounter := mm_atomic.LoadUint64(&m.afterAddCardsReviewsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddCardsReviewsMock.defaultExpectation != nil && afterAddCardsReviewsCounter < 1 {
		if m.AddCardsReviewsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReviewWriterMock.AddCardsReviews at\n%s", m.AddCardsReviewsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReviewWriterMock.AddCardsReviews at\n%s with params: %#v", m.AddCardsReviewsMock.defaultExpectation.expectationOrigins.origin, *m.AddCardsReviewsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddCardsReviews != nil && afterAddCardsReviewsCounter < 1 {
		m.t.Errorf("Expected call to ReviewWriterMock.AddCardsReviews at\n%s", m.funcAddCardsReviewsOrigin)
	}

	if !m.AddCardsReviewsMock.invocationsDone() && afterAddCardsReviewsCounter > 0 {
		m.t.Errorf("Expected %d calls to ReviewWriterMock.AddCardsReviews at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddCardsReviewsMock.expectedInvocations), m.AddCardsReviewsMock.expectedInvocationsOrigin, afterAddCardsReviewsCounter)
	}
}

type mReviewWriterMockDeleteNotUsedReviews struct {
	optional           bool
	mock               *ReviewWriterMock
	defaultExpectation *ReviewWriterMockDeleteNotUsedReviewsExpectation
	expectations       []*ReviewWriterMockDeleteNotUsedReviewsExpectation

	callArgs []*ReviewWriterMockDeleteNotUsedReviewsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReviewWriterMockDeleteNotUsedReviewsExpectation specifies expectation struct of the ReviewWriter.DeleteNotUsedReviews
type ReviewWriterMockDeleteNotUsedReviewsExpectation struct {
	mock               *ReviewWriterMock
	params             *ReviewWriterMockDeleteNotUsedReviewsParams
	paramPtrs          *ReviewWriterMockDeleteNotUsedReviewsParamPtrs
	expectationOrigins ReviewWriterMockDeleteNotUsedReviewsExpectationOrigins
	results            *ReviewWriterMockDeleteNotUsedReviewsResults
	returnOrigin       string
	Counter            uint64
}

// ReviewWriterMockDeleteNotUsedReviewsParams contains parameters of the ReviewWriter.DeleteNotUsedReviews
type ReviewWriterMockDeleteNotUsedReviewsParams struct {
	ctx     context.Context
	userId  model.UserId
	groupId model.GroupId
}

// ReviewWriterMockDeleteNotUsedReviewsParamPtrs contains pointers to parameters of the ReviewWriter.DeleteNotUsedReviews
type ReviewWriterMockDeleteNotUsedReviewsParamPtrs struct {
	ctx     *context.Context
	userId  *model.UserId
	groupId *model.GroupId
}

// ReviewWriterMockDeleteNotUsedReviewsResults contains results of the ReviewWriter.DeleteNotUsedReviews
type ReviewWriterMockDeleteNotUsedReviewsResults struct {
	err error
}

// ReviewWriterMockDeleteNotUsedReviewsOrigins contains origins of expectations of the ReviewWriter.DeleteNotUsedReviews
type ReviewWriterMockDeleteNotUsedReviewsExpectationOrigins struct {
	origin        string
	originCtx     string
	originUserId  string
	originGroupId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNotUsedReviews *mReviewWriterMockDeleteNotUsedReviews) Optional() *mReviewWriterMockDeleteNotUsedReviews {
	mmDeleteNotUsedReviews.optional = true
	return mmDeleteNotUsedReviews
}

// Expect sets up expected params for ReviewWriter.DeleteNotUsedReviews
func (mmDeleteNotUsedReviews *mReviewWriterMockDeleteNotUsedReviews) Expect(ctx context.Context, userId model.UserId, groupId model.GroupId) *mReviewWriterMockDeleteNotUsedReviews {
	if mmDeleteNotUsedReviews.mock.funcDeleteNotUsedReviews != nil {
		mmDeleteNotUsedReviews.mock.t.Fatalf("ReviewWriterMock.DeleteNotUsedReviews mock is already set by Set")
	}

	if mmDeleteNotUsedReviews.defaultExpectation == nil {
		mmDeleteNotUsedReviews.defaultExpectation = &ReviewWriterMockDeleteNotUsedReviewsExpectation{}
	}

	if mmDeleteNotUsedReviews.defaultExpectation.paramPtrs != nil {
		mmDeleteNotUsedReviews.mock.t.Fatalf("ReviewWriterMock.DeleteNotUsedReviews mock is already set by ExpectParams functions")
	}

	mmDeleteNotUsedReviews.defaultExpectation.params = &ReviewWriterMockDeleteNotUsedReviewsParams{ctx, userId, groupId}
	mmDeleteNotUsedReviews.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteNotUsedReviews.expectations {
		if minimock.Equal(e.params, mmDeleteNotUsedReviews.defaultExpectation.params) {
			mmDeleteNotUsedReviews.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNotUsedReviews.defaultExpectation.params)
		}
	}

	return mmDeleteNotUsedReviews
}

// ExpectCtxParam1 sets up expected param ctx for ReviewWriter.DeleteNotUsedReviews
func (mmDeleteNotUsedReviews *mReviewWriterMockDeleteNotUsedReviews) ExpectCtxParam1(ctx context.Context) *mReviewWriterMockDeleteNotUsedReviews {
	if mmDeleteNotUsedReviews.mock.funcDeleteNotUsedReviews != nil {
		mmDeleteNotUsedReviews.mock.t.Fatalf("ReviewWriterMock.DeleteNotUsedReviews mock is already set by Set")
	}

	if mmDeleteNotUsedReviews.defaultExpectation == nil {
		mmDeleteNotUsedReviews.defaultExpectation = &ReviewWriterMockDeleteNotUsedReviewsExpectation{}
	}

	if mmDeleteNotUsedReviews.defaultExpectation.params != nil {
		mmDeleteNotUsedReviews.mock.t.Fatalf("ReviewWriterMock.DeleteNotUsedReviews mock is already set by Expect")
	}

	if mmDeleteNotUsedReviews.defaultExpectation.paramPtrs == nil {
		mmDeleteNotUsedReviews.defaultExpectation.paramPtrs = &ReviewWriterMockDeleteNotUsedReviewsParamPtrs{}
	}
	mmDeleteNotUsedReviews.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteNotUsedReviews.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteNotUsedReviews
}

// ExpectUserIdParam2 sets up expected param userId for ReviewWriter.DeleteNotUsedReviews
func (mmDeleteNotUsedReviews *mReviewWriterMockDeleteNotUsedReviews) ExpectUserIdParam2(userId model.UserId) *mReviewWriterMockDeleteNotUsedReviews {
	if mmDeleteNotUsedReviews.mock.funcDeleteNotUsedReviews != nil {
		mmDeleteNotUsedReviews.mock.t.Fatalf("ReviewWriterMock.DeleteNotUsedReviews mock is already set by Set")
	}

	if mmDeleteNotUsedReviews.defaultExpectation == nil {
		mmDeleteNotUsedReviews.defaultExpectation = &ReviewWriterMockDeleteNotUsedReviewsExpectation{}
	}

	if mmDeleteNotUsedReviews.defaultExpectation.params != nil {
		mmDeleteNotUsedReviews.mock.t.Fatalf("ReviewWriterMock.DeleteNotUsedReviews mock is already set by Expect")
	}

	if mmDeleteNotUsedReviews.defaultExpectation.paramPtrs == nil {
		mmDeleteNotUsedReviews.defaultExpectation.paramPtrs = &ReviewWriterMockDeleteNotUsedReviewsParamPtrs{}
	}
	mmDeleteNotUsedReviews.defaultExpectation.paramPtrs.userId = &userId
	mmDeleteNotUsedReviews.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmDeleteNotUsedReviews
}

// ExpectGroupIdParam3 sets up expected param groupId for ReviewWriter.DeleteNotUsedReviews
func (mmDeleteNotUsedReviews *mReviewWriterMockDeleteNotUsedReviews) ExpectGroupIdParam3(groupId model.GroupId) *mReviewWriterMockDeleteNotUsedReviews {
	if mmDeleteNotUsedReviews.mock.funcDeleteNotUsedReviews != nil {
		mmDeleteNotUsedReviews.mock.t.Fatalf("ReviewWriterMock.DeleteNotUsedReviews mock is already set by Set")
	}

	if mmDeleteNotUsedReviews.defaultExpectation == nil {
		mmDeleteNotUsedReviews.defaultExpectation = &ReviewWriterMockDeleteNotUsedReviewsExpectation{}
	}

	if mmDeleteNotUsedReviews.defaultExpectation.params != nil {
		mmDeleteNotUsedReviews.mock.t.Fatalf("ReviewWriterMock.DeleteNotUsedReviews mock is already set by Expect")
	}

	if mmDeleteNotUsedReviews.defaultExpectation.paramPtrs == nil {
		mmDeleteNotUsedReviews.defaultExpectation.paramPtrs = &ReviewWriterMockDeleteNotUsedReviewsParamPtrs{}
	}
	mmDeleteNotUsedReviews.defaultExpectation.paramPtrs.groupId = &groupId
	mmDeleteNotUsedReviews.defaultExpectation.expectationOrigins.originGroupId = minimock.CallerInfo(1)

	return mmDeleteNotUsedReviews
}

// Inspect accepts an inspector function that has same arguments as the ReviewWriter.DeleteNotUsedReviews
func (mmDeleteNotUsedReviews *mReviewWriterMockDeleteNotUsedReviews) Inspect(f func(ctx context.Context, userId model.UserId, groupId model.GroupId)) *mReviewWriterMockDeleteNotUsedReviews {
	if mmDeleteNotUsedReviews.mock.inspectFuncDeleteNotUsedReviews != nil {
		mmDeleteNotUsedReviews.mock.t.Fatalf("Inspect function is already set for ReviewWriterMock.DeleteNotUsedReviews")
	}

	mmDeleteNotUsedReviews.mock.inspectFuncDeleteNotUsedReviews = f

	return mmDeleteNotUsedReviews
}

// Return sets up results that will be returned by ReviewWriter.DeleteNotUsedReviews
func (mmDeleteNotUsedReviews *mReviewWriterMockDeleteNotUsedReviews) Return(err error) *ReviewWriterMock {
	if mmDeleteNotUsedReviews.mock.funcDeleteNotUsedReviews != nil {
		mmDeleteNotUsedReviews.mock.t.Fatalf("ReviewWriterMock.DeleteNotUsedReviews mock is already set by Set")
	}

	if mmDeleteNotUsedReviews.defaultExpectation == nil {
		mmDeleteNotUsedReviews.defaultExpectation = &ReviewWriterMockDeleteNotUsedReviewsExpectation{mock: mmDeleteNotUsedReviews.mock}
	}
	mmDeleteNotUsedReviews.defaultExpectation.results = &ReviewWriterMockDeleteNotUsedReviewsResults{err}
	mmDeleteNotUsedReviews.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteNotUsedReviews.mock
}

// Set uses given function f to mock the ReviewWriter.DeleteNotUsedReviews method
func (mmDeleteNotUsedReviews *mReviewWriterMockDeleteNotUsedReviews) Set(f func(ctx context.Context, userId model.UserId, groupId model.GroupId) (err error)) *ReviewWriterMock {
	if mmDeleteNotUsedReviews.defaultExpectation != nil {
		mmDeleteNotUsedReviews.mock.t.Fatalf("Default expectation is already set for the ReviewWriter.DeleteNotUsedReviews method")
	}

	if len(mmDeleteNotUsedReviews.expectations) > 0 {
		mmDeleteNotUsedReviews.mock.t.Fatalf("Some expectations are already set for the ReviewWriter.DeleteNotUsedReviews method")
	}

	mmDeleteNotUsedReviews.mock.funcDeleteNotUsedReviews = f
	mmDeleteNotUsedReviews.mock.funcDeleteNotUsedReviewsOrigin = minimock.CallerInfo(1)
	return mmDeleteNotUsedReviews.mock
}

// When sets expectation for the ReviewWriter.DeleteNotUsedReviews which will trigger the result defined by the following
// Then helper
func (mmDeleteNotUsedReviews *mReviewWriterMockDeleteNotUsedReviews) When(ctx context.Context, userId model.UserId, groupId model.GroupId) *ReviewWriterMockDeleteNotUsedReviewsExpectation {
	if mmDeleteNotUsedReviews.mock.funcDeleteNotUsedReviews != nil {
		mmDeleteNotUsedReviews.mock.t.Fatalf("ReviewWriterMock.DeleteNotUsedReviews mock is already set by Set")
	}

	expectation := &ReviewWriterMockDeleteNotUsedReviewsExpectation{
		mock:               mmDeleteNotUsedReviews.mock,
		params:             &ReviewWriterMockDeleteNotUsedReviewsParams{ctx, userId, groupId},
		expectationOrigins: ReviewWriterMockDeleteNotUsedReviewsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteNotUsedReviews.expectations = append(mmDeleteNotUsedReviews.expectations, expectation)
	return expectation
}

// Then sets up ReviewWriter.DeleteNotUsedReviews return parameters for the expectation previously defined by the When method
func (e *ReviewWriterMockDeleteNotUsedReviewsExpectation) Then(err error) *ReviewWriterMock {
	e.results = &ReviewWriterMockDeleteNotUsedReviewsResults{err}
	return e.mock
}

// Times sets number of times ReviewWriter.DeleteNotUsedReviews should be invoked
func (mmDeleteNotUsedReviews *mReviewWriterMockDeleteNotUsedReviews) Times(n uint64) *mReviewWriterMockDeleteNotUsedReviews {
	if n == 0 {
		mmDeleteNotUsedReviews.mock.t.Fatalf("Times of ReviewWriterMock.DeleteNotUsedReviews mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNotUsedReviews.expectedInvocations, n)
	mmDeleteNotUsedReviews.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteNotUsedReviews
}

func (mmDeleteNotUsedReviews *mReviewWriterMockDeleteNotUsedReviews) invocationsDone() bool {
	if len(mmDeleteNotUsedReviews.expectations) == 0 && mmDeleteNotUsedReviews.defaultExpectation == nil && mmDeleteNotUsedReviews.mock.funcDeleteNotUsedReviews == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNotUsedReviews.mock.afterDeleteNotUsedReviewsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNotUsedReviews.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNotUsedReviews implements mm_module.ReviewWriter
func (mmDeleteNotUsedReviews *ReviewWriterMock) DeleteNotUsedReviews(ctx context.Context, userId model.UserId, groupId model.GroupId) (err error) {
	mm_atomic.AddUint64(&mmDeleteNotUsedReviews.beforeDeleteNotUsedReviewsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNotUsedReviews.afterDeleteNotUsedReviewsCounter, 1)

	mmDeleteNotUsedReviews.t.Helper()

	if mmDeleteNotUsedReviews.inspectFuncDeleteNotUsedReviews != nil {
		mmDeleteNotUsedReviews.inspectFuncDeleteNotUsedReviews(ctx, userId, groupId)
	}

	mm_params := ReviewWriterMockDeleteNotUsedReviewsParams{ctx, userId, groupId}

	// Record call args
	mmDeleteNotUsedReviews.DeleteNotUsedReviewsMock.mutex.Lock()
	mmDeleteNotUsedReviews.DeleteNotUsedReviewsMock.callArgs = append(mmDeleteNotUsedReviews.DeleteNotUsedReviewsMock.callArgs, &mm_params)
	mmDeleteNotUsedReviews.DeleteNotUsedReviewsMock.mutex.Unlock()

	for _, e := range mmDeleteNotUsedReviews.DeleteNotUsedReviewsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteNotUsedReviews.DeleteNotUsedReviewsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNotUsedReviews.DeleteNotUsedReviewsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNotUsedReviews.DeleteNotUsedReviewsMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNotUsedReviews.DeleteNotUsedReviewsMock.defaultExpectation.paramPtrs

		mm_got := ReviewWriterMockDeleteNotUsedReviewsParams{ctx, userId, groupId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteNotUsedReviews.t.Errorf("ReviewWriterMock.DeleteNotUsedReviews got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNotUsedReviews.DeleteNotUsedReviewsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmDeleteNotUsedReviews.t.Errorf("ReviewWriterMock.DeleteNotUsedReviews got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNotUsedReviews.DeleteNotUsedReviewsMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

			if mm_want_ptrs.groupId != nil && !minimock.Equal(*mm_want_ptrs.groupId, mm_got.groupId) {
				mmDeleteNotUsedReviews.t.Errorf("ReviewWriterMock.DeleteNotUsedReviews got unexpected parameter groupId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNotUsedReviews.DeleteNotUsedReviewsMock.defaultExpectation.expectationOrigins.originGroupId, *mm_want_ptrs.groupId, mm_got.groupId, minimock.Diff(*mm_want_ptrs.groupId, mm_got.groupId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNotUsedReviews.t.Errorf("ReviewWriterMock.DeleteNotUsedReviews got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteNotUsedReviews.DeleteNotUsedReviewsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteNotUsedReviews.DeleteNotUsedReviewsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteNotUsedReviews.t.Fatal("No results are set for the ReviewWriterMock.DeleteNotUsedReviews")
		}
		return (*mm_results).err
	}
	if mmDeleteNotUsedReviews.funcDeleteNotUsedReviews != nil {
		return mmDeleteNotUsedReviews.funcDeleteNotUsedReviews(ctx, userId, groupId)
	}
	mmDeleteNotUsedReviews.t.Fatalf("Unexpected call to ReviewWriterMock.DeleteNotUsedReviews. %v %v %v", ctx, userId, groupId)
	return
}

// DeleteNotUsedReviewsAfterCounter returns a count of finished ReviewWriterMock.DeleteNotUsedReviews invocations
func (mmDeleteNotUsedReviews *ReviewWriterMock) DeleteNotUsedReviewsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNotUsedReviews.afterDeleteNotUsedReviewsCounter)
}

// DeleteNotUsedReviewsBeforeCounter returns a count of ReviewWriterMock.DeleteNotUsedReviews invocations
func (mmDeleteNotUsedReviews *ReviewWriterMock) DeleteNotUsedReviewsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNotUsedReviews.beforeDeleteNotUsedReviewsCounter)
}

// Calls returns a list of arguments used in each call to ReviewWriterMock.DeleteNotUsedReviews.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNotUsedReviews *mReviewWriterMockDeleteNotUsedReviews) Calls() []*ReviewWriterMockDeleteNotUsedReviewsParams {
	mmDeleteNotUsedReviews.mutex.RLock()

	argCopy := make([]*ReviewWriterMockDeleteNotUsedReviewsParams, len(mmDeleteNotUsedReviews.callArgs))
	copy(argCopy, mmDeleteNotUsedReviews.callArgs)

	mmDeleteNotUsedReviews.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNotUsedReviewsDone returns true if the count of the DeleteNotUsedReviews invocations corresponds
// the number of defined expectations
func (m *ReviewWriterMock) MinimockDeleteNotUsedReviewsDone() bool {
	if m.DeleteNotUsedReviewsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNotUsedReviewsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNotUsedReviewsMock.invocationsDone()
}

// MinimockDeleteNotUsedReviewsInspect logs each unmet expectation
func (m *ReviewWriterMock) MinimockDeleteNotUsedReviewsInspect() {
	for _, e := range m.DeleteNotUsedReviewsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReviewWriterMock.DeleteNotUsedReviews at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteNotUsedReviewsCounter := mm_atomic.LoadUint64(&m.afterDeleteNotUsedReviewsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNotUsedReviewsMock.defaultExpectation != nil && afterDeleteNotUsedReviewsCounter < 1 {
		if m.DeleteNotUsedReviewsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReviewWriterMock.DeleteNotUsedReviews at\n%s", m.DeleteNotUsedReviewsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReviewWriterMock.DeleteNotUsedReviews at\n%s with params: %#v", m.DeleteNotUsedReviewsMock.defaultExpectation.expectationOrigins.origin, *m.DeleteNotUsedReviewsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNotUsedReviews != nil && afterDeleteNotUsedReviewsCounter < 1 {
		m.t.Errorf("Expected call to ReviewWriterMock.DeleteNotUsedReviews at\n%s", m.funcDeleteNotUsedReviewsOrigin)
	}

	if !m.DeleteNotUsedReviewsMock.invocationsDone() && afterDeleteNotUsedReviewsCounter > 0 {
		m.t.Errorf("Expected %d calls to ReviewWriterMock.DeleteNotUsedReviews at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNotUsedReviewsMock.expectedInvocations), m.DeleteNotUsedReviewsMock.expectedInvocationsOrigin, afterDeleteNotUsedReviewsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ReviewWriterMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddCardsReviewsInspect()

			m.MinimockDeleteNotUsedReviewsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ReviewWriterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ReviewWriterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddCardsReviewsDone() &&
		m.MinimockDeleteNotUsedReviewsDone()
}
