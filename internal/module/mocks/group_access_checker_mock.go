// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/iamvkosarev/learning-cards/internal/module.GroupAccessChecker -o group_access_checker_mock.go -n GroupAccessCheckerMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/iamvkosarev/learning-cards/internal/model"
)

// GroupAccessCheckerMock implements mm_module.GroupAccessChecker
type GroupAccessCheckerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckReadGroupAccess          func(ctx context.Context, groupId model.GroupId) (err error)
	funcCheckReadGroupAccessOrigin    string
	inspectFuncCheckReadGroupAccess   func(ctx context.Context, groupId model.GroupId)
	afterCheckReadGroupAccessCounter  uint64
	beforeCheckReadGroupAccessCounter uint64
	CheckReadGroupAccessMock          mGroupAccessCheckerMockCheckReadGroupAccess

	funcCheckWriteGroupAccess          func(ctx context.Context, groupId model.GroupId) (err error)
	funcCheckWriteGroupAccessOrigin    string
	inspectFuncCheckWriteGroupAccess   func(ctx context.Context, groupId model.GroupId)
	afterCheckWriteGroupAccessCounter  uint64
	beforeCheckWriteGroupAccessCounter uint64
	CheckWriteGroupAccessMock          mGroupAccessCheckerMockCheckWriteGroupAccess
}

// NewGroupAccessCheckerMock returns a mock for mm_module.GroupAccessChecker
func NewGroupAccessCheckerMock(t minimock.Tester) *GroupAccessCheckerMock {
	m := &GroupAccessCheckerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckReadGroupAccessMock = mGroupAccessCheckerMockCheckReadGroupAccess{mock: m}
	m.CheckReadGroupAccessMock.callArgs = []*GroupAccessCheckerMockCheckReadGroupAccessParams{}

	m.CheckWriteGroupAccessMock = mGroupAccessCheckerMockCheckWriteGroupAccess{mock: m}
	m.CheckWriteGroupAccessMock.callArgs = []*GroupAccessCheckerMockCheckWriteGroupAccessParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mGroupAccessCheckerMockCheckReadGroupAccess struct {
	optional           bool
	mock               *GroupAccessCheckerMock
	defaultExpectation *GroupAccessCheckerMockCheckReadGroupAccessExpectation
	expectations       []*GroupAccessCheckerMockCheckReadGroupAccessExpectation

	callArgs []*GroupAccessCheckerMockCheckReadGroupAccessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupAccessCheckerMockCheckReadGroupAccessExpectation specifies expectation struct of the GroupAccessChecker.CheckReadGroupAccess
type GroupAccessCheckerMockCheckReadGroupAccessExpectation struct {
	mock               *GroupAccessCheckerMock
	params             *GroupAccessCheckerMockCheckReadGroupAccessParams
	paramPtrs          *GroupAccessCheckerMockCheckReadGroupAccessParamPtrs
	expectationOrigins GroupAccessCheckerMockCheckReadGroupAccessExpectationOrigins
	results            *GroupAccessCheckerMockCheckReadGroupAccessResults
	returnOrigin       string
	Counter            uint64
}

// GroupAccessCheckerMockCheckReadGroupAccessParams contains parameters of the GroupAccessChecker.CheckReadGroupAccess
type GroupAccessCheckerMockCheckReadGroupAccessParams struct {
	ctx     context.Context
	groupId model.GroupId
}

// GroupAccessCheckerMockCheckReadGroupAccessParamPtrs contains pointers to parameters of the GroupAccessChecker.CheckReadGroupAccess
type GroupAccessCheckerMockCheckReadGroupAccessParamPtrs struct {
	ctx     *context.Context
	groupId *model.GroupId
}

// GroupAccessCheckerMockCheckReadGroupAccessResults contains results of the GroupAccessChecker.CheckReadGroupAccess
type GroupAccessCheckerMockCheckReadGroupAccessResults struct {
	err error
}

// GroupAccessCheckerMockCheckReadGroupAccessOrigins contains origins of expectations of the GroupAccessChecker.CheckReadGroupAccess
type GroupAccessCheckerMockCheckReadGroupAccessExpectationOrigins struct {
	origin        string
	originCtx     string
	originGroupId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckReadGroupAccess *mGroupAccessCheckerMockCheckReadGroupAccess) Optional() *mGroupAccessCheckerMockCheckReadGroupAccess {
	mmCheckReadGroupAccess.optional = true
	return mmCheckReadGroupAccess
}

// Expect sets up expected params for GroupAccessChecker.CheckReadGroupAccess
func (mmCheckReadGroupAccess *mGroupAccessCheckerMockCheckReadGroupAccess) Expect(ctx context.Context, groupId model.GroupId) *mGroupAccessCheckerMockCheckReadGroupAccess {
	if mmCheckReadGroupAccess.mock.funcCheckReadGroupAccess != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckReadGroupAccess mock is already set by Set")
	}

	if mmCheckReadGroupAccess.defaultExpectation == nil {
		mmCheckReadGroupAccess.defaultExpectation = &GroupAccessCheckerMockCheckReadGroupAccessExpectation{}
	}

	if mmCheckReadGroupAccess.defaultExpectation.paramPtrs != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckReadGroupAccess mock is already set by ExpectParams functions")
	}

	mmCheckReadGroupAccess.defaultExpectation.params = &GroupAccessCheckerMockCheckReadGroupAccessParams{ctx, groupId}
	mmCheckReadGroupAccess.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckReadGroupAccess.expectations {
		if minimock.Equal(e.params, mmCheckReadGroupAccess.defaultExpectation.params) {
			mmCheckReadGroupAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckReadGroupAccess.defaultExpectation.params)
		}
	}

	return mmCheckReadGroupAccess
}

// ExpectCtxParam1 sets up expected param ctx for GroupAccessChecker.CheckReadGroupAccess
func (mmCheckReadGroupAccess *mGroupAccessCheckerMockCheckReadGroupAccess) ExpectCtxParam1(ctx context.Context) *mGroupAccessCheckerMockCheckReadGroupAccess {
	if mmCheckReadGroupAccess.mock.funcCheckReadGroupAccess != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckReadGroupAccess mock is already set by Set")
	}

	if mmCheckReadGroupAccess.defaultExpectation == nil {
		mmCheckReadGroupAccess.defaultExpectation = &GroupAccessCheckerMockCheckReadGroupAccessExpectation{}
	}

	if mmCheckReadGroupAccess.defaultExpectation.params != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckReadGroupAccess mock is already set by Expect")
	}

	if mmCheckReadGroupAccess.defaultExpectation.paramPtrs == nil {
		mmCheckReadGroupAccess.defaultExpectation.paramPtrs = &GroupAccessCheckerMockCheckReadGroupAccessParamPtrs{}
	}
	mmCheckReadGroupAccess.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckReadGroupAccess.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckReadGroupAccess
}

// ExpectGroupIdParam2 sets up expected param groupId for GroupAccessChecker.CheckReadGroupAccess
func (mmCheckReadGroupAccess *mGroupAccessCheckerMockCheckReadGroupAccess) ExpectGroupIdParam2(groupId model.GroupId) *mGroupAccessCheckerMockCheckReadGroupAccess {
	if mmCheckReadGroupAccess.mock.funcCheckReadGroupAccess != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckReadGroupAccess mock is already set by Set")
	}

	if mmCheckReadGroupAccess.defaultExpectation == nil {
		mmCheckReadGroupAccess.defaultExpectation = &GroupAccessCheckerMockCheckReadGroupAccessExpectation{}
	}

	if mmCheckReadGroupAccess.defaultExpectation.params != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckReadGroupAccess mock is already set by Expect")
	}

	if mmCheckReadGroupAccess.defaultExpectation.paramPtrs == nil {
		mmCheckReadGroupAccess.defaultExpectation.paramPtrs = &GroupAccessCheckerMockCheckReadGroupAccessParamPtrs{}
	}
	mmCheckReadGroupAccess.defaultExpectation.paramPtrs.groupId = &groupId
	mmCheckReadGroupAccess.defaultExpectation.expectationOrigins.originGroupId = minimock.CallerInfo(1)

	return mmCheckReadGroupAccess
}

// Inspect accepts an inspector function that has same arguments as the GroupAccessChecker.CheckReadGroupAccess
func (mmCheckReadGroupAccess *mGroupAccessCheckerMockCheckReadGroupAccess) Inspect(f func(ctx context.Context, groupId model.GroupId)) *mGroupAccessCheckerMockCheckReadGroupAccess {
	if mmCheckReadGroupAccess.mock.inspectFuncCheckReadGroupAccess != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("Inspect function is already set for GroupAccessCheckerMock.CheckReadGroupAccess")
	}

	mmCheckReadGroupAccess.mock.inspectFuncCheckReadGroupAccess = f

	return mmCheckReadGroupAccess
}

// Return sets up results that will be returned by GroupAccessChecker.CheckReadGroupAccess
func (mmCheckReadGroupAccess *mGroupAccessCheckerMockCheckReadGroupAccess) Return(err error) *GroupAccessCheckerMock {
	if mmCheckReadGroupAccess.mock.funcCheckReadGroupAccess != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckReadGroupAccess mock is already set by Set")
	}

	if mmCheckReadGroupAccess.defaultExpectation == nil {
		mmCheckReadGroupAccess.defaultExpectation = &GroupAccessCheckerMockCheckReadGroupAccessExpectation{mock: mmCheckReadGroupAccess.mock}
	}
	mmCheckReadGroupAccess.defaultExpectation.results = &GroupAccessCheckerMockCheckReadGroupAccessResults{err}
	mmCheckReadGroupAccess.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckReadGroupAccess.mock
}

// Set uses given function f to mock the GroupAccessChecker.CheckReadGroupAccess method
func (mmCheckReadGroupAccess *mGroupAccessCheckerMockCheckReadGroupAccess) Set(f func(ctx context.Context, groupId model.GroupId) (err error)) *GroupAccessCheckerMock {
	if mmCheckReadGroupAccess.defaultExpectation != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("Default expectation is already set for the GroupAccessChecker.CheckReadGroupAccess method")
	}

	if len(mmCheckReadGroupAccess.expectations) > 0 {
		mmCheckReadGroupAccess.mock.t.Fatalf("Some expectations are already set for the GroupAccessChecker.CheckReadGroupAccess method")
	}

	mmCheckReadGroupAccess.mock.funcCheckReadGroupAccess = f
	mmCheckReadGroupAccess.mock.funcCheckReadGroupAccessOrigin = minimock.CallerInfo(1)
	return mmCheckReadGroupAccess.mock
}

// When sets expectation for the GroupAccessChecker.CheckReadGroupAccess which will trigger the result defined by the following
// Then helper
func (mmCheckReadGroupAccess *mGroupAccessCheckerMockCheckReadGroupAccess) When(ctx context.Context, groupId model.GroupId) *GroupAccessCheckerMockCheckReadGroupAccessExpectation {
	if mmCheckReadGroupAccess.mock.funcCheckReadGroupAccess != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckReadGroupAccess mock is already set by Set")
	}

	expectation := &GroupAccessCheckerMockCheckReadGroupAccessExpectation{
		mock:               mmCheckReadGroupAccess.mock,
		params:             &GroupAccessCheckerMockCheckReadGroupAccessParams{ctx, groupId},
		expectationOrigins: GroupAccessCheckerMockCheckReadGroupAccessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckReadGroupAccess.expectations = append(mmCheckReadGroupAccess.expectations, expectation)
	return expectation
}

// Then sets up GroupAccessChecker.CheckReadGroupAccess return parameters for the expectation previously defined by the When method
func (e *GroupAccessCheckerMockCheckReadGroupAccessExpectation) Then(err error) *GroupAccessCheckerMock {
	e.results = &GroupAccessCheckerMockCheckReadGroupAccessResults{err}
	return e.mock
}

// Times sets number of times GroupAccessChecker.CheckReadGroupAccess should be invoked
func (mmCheckReadGroupAccess *mGroupAccessCheckerMockCheckReadGroupAccess) Times(n uint64) *mGroupAccessCheckerMockCheckReadGroupAccess {
	if n == 0 {
		mmCheckReadGroupAccess.mock.t.Fatalf("Times of GroupAccessCheckerMock.CheckReadGroupAccess mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckReadGroupAccess.expectedInvocations, n)
	mmCheckReadGroupAccess.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckReadGroupAccess
}

func (mmCheckReadGroupAccess *mGroupAccessCheckerMockCheckReadGroupAccess) invocationsDone() bool {
	if len(mmCheckReadGroupAccess.expectations) == 0 && mmCheckReadGroupAccess.defaultExpectation == nil && mmCheckReadGroupAccess.mock.funcCheckReadGroupAccess == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckReadGroupAccess.mock.afterCheckReadGroupAccessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckReadGroupAccess.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckReadGroupAccess implements mm_module.GroupAccessChecker
func (mmCheckReadGroupAccess *GroupAccessCheckerMock) CheckReadGroupAccess(ctx context.Context, groupId model.GroupId) (err error) {
	mm_atomic.AddUint64(&mmCheckReadGroupAccess.beforeCheckReadGroupAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckReadGroupAccess.afterCheckReadGroupAccessCounter, 1)

	mmCheckReadGroupAccess.t.Helper()

	if mmCheckReadGroupAccess.inspectFuncCheckReadGroupAccess != nil {
		mmCheckReadGroupAccess.inspectFuncCheckReadGroupAccess(ctx, groupId)
	}

	mm_params := GroupAccessCheckerMockCheckReadGroupAccessParams{ctx, groupId}

	// Record call args
	mmCheckReadGroupAccess.CheckReadGroupAccessMock.mutex.Lock()
	mmCheckReadGroupAccess.CheckReadGroupAccessMock.callArgs = append(mmCheckReadGroupAccess.CheckReadGroupAccessMock.callArgs, &mm_params)
	mmCheckReadGroupAccess.CheckReadGroupAccessMock.mutex.Unlock()

	for _, e := range mmCheckReadGroupAccess.CheckReadGroupAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation.params
		mm_want_ptrs := mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation.paramPtrs

		mm_got := GroupAccessCheckerMockCheckReadGroupAccessParams{ctx, groupId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckReadGroupAccess.t.Errorf("GroupAccessCheckerMock.CheckReadGroupAccess got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.groupId != nil && !minimock.Equal(*mm_want_ptrs.groupId, mm_got.groupId) {
				mmCheckReadGroupAccess.t.Errorf("GroupAccessCheckerMock.CheckReadGroupAccess got unexpected parameter groupId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation.expectationOrigins.originGroupId, *mm_want_ptrs.groupId, mm_got.groupId, minimock.Diff(*mm_want_ptrs.groupId, mm_got.groupId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckReadGroupAccess.t.Errorf("GroupAccessCheckerMock.CheckReadGroupAccess got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckReadGroupAccess.t.Fatal("No results are set for the GroupAccessCheckerMock.CheckReadGroupAccess")
		}
		return (*mm_results).err
	}
	if mmCheckReadGroupAccess.funcCheckReadGroupAccess != nil {
		return mmCheckReadGroupAccess.funcCheckReadGroupAccess(ctx, groupId)
	}
	mmCheckReadGroupAccess.t.Fatalf("Unexpected call to GroupAccessCheckerMock.CheckReadGroupAccess. %v %v", ctx, groupId)
	return
}

// CheckReadGroupAccessAfterCounter returns a count of finished GroupAccessCheckerMock.CheckReadGroupAccess invocations
func (mmCheckReadGroupAccess *GroupAccessCheckerMock) CheckReadGroupAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckReadGroupAccess.afterCheckReadGroupAccessCounter)
}

// CheckReadGroupAccessBeforeCounter returns a count of GroupAccessCheckerMock.CheckReadGroupAccess invocations
func (mmCheckReadGroupAccess *GroupAccessCheckerMock) CheckReadGroupAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckReadGroupAccess.beforeCheckReadGroupAccessCounter)
}

// Calls returns a list of arguments used in each call to GroupAccessCheckerMock.CheckReadGroupAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckReadGroupAccess *mGroupAccessCheckerMockCheckReadGroupAccess) Calls() []*GroupAccessCheckerMockCheckReadGroupAccessParams {
	mmCheckReadGroupAccess.mutex.RLock()

	argCopy := make([]*GroupAccessCheckerMockCheckReadGroupAccessParams, len(mmCheckReadGroupAccess.callArgs))
	copy(argCopy, mmCheckReadGroupAccess.callArgs)

	mmCheckReadGroupAccess.mutex.RUnlock()

	return argCopy
}

// MinimockCheckReadGroupAccessDone returns true if the count of the CheckReadGroupAccess invocations corresponds
// the number of defined expectations
func (m *GroupAccessCheckerMock) MinimockCheckReadGroupAccessDone() bool {
	if m.CheckReadGroupAccessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckReadGroupAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckReadGroupAccessMock.invocationsDone()
}

// MinimockCheckReadGroupAccessInspect logs each unmet expectation
func (m *GroupAccessCheckerMock) MinimockCheckReadGroupAccessInspect() {
	for _, e := range m.CheckReadGroupAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupAccessCheckerMock.CheckReadGroupAccess at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckReadGroupAccessCounter := mm_atomic.LoadUint64(&m.afterCheckReadGroupAccessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckReadGroupAccessMock.defaultExpectation != nil && afterCheckReadGroupAccessCounter < 1 {
		if m.CheckReadGroupAccessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupAccessCheckerMock.CheckReadGroupAccess at\n%s", m.CheckReadGroupAccessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupAccessCheckerMock.CheckReadGroupAccess at\n%s with params: %#v", m.CheckReadGroupAccessMock.defaultExpectation.expectationOrigins.origin, *m.CheckReadGroupAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckReadGroupAccess != nil && afterCheckReadGroupAccessCounter < 1 {
		m.t.Errorf("Expected call to GroupAccessCheckerMock.CheckReadGroupAccess at\n%s", m.funcCheckReadGroupAccessOrigin)
	}

	if !m.CheckReadGroupAccessMock.invocationsDone() && afterCheckReadGroupAccessCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupAccessCheckerMock.CheckReadGroupAccess at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckReadGroupAccessMock.expectedInvocations), m.CheckReadGroupAccessMock.expectedInvocationsOrigin, afterCheckReadGroupAccessCounter)
	}
}

type mGroupAccessCheckerMockCheckWriteGroupAccess struct {
	optional           bool
	mock               *GroupAccessCheckerMock
	defaultExpectation *GroupAccessCheckerMockCheckWriteGroupAccessExpectation
	expectations       []*GroupAccessCheckerMockCheckWriteGroupAccessExpectation

	callArgs []*GroupAccessCheckerMockCheckWriteGroupAccessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupAccessCheckerMockCheckWriteGroupAccessExpectation specifies expectation struct of the GroupAccessChecker.CheckWriteGroupAccess
type GroupAccessCheckerMockCheckWriteGroupAccessExpectation struct {
	mock               *GroupAccessCheckerMock
	params             *GroupAccessCheckerMockCheckWriteGroupAccessParams
	paramPtrs          *GroupAccessCheckerMockCheckWriteGroupAccessParamPtrs
	expectationOrigins GroupAccessCheckerMockCheckWriteGroupAccessExpectationOrigins
	results            *GroupAccessCheckerMockCheckWriteGroupAccessResults
	returnOrigin       string
	Counter            uint64
}

// GroupAccessCheckerMockCheckWriteGroupAccessParams contains parameters of the GroupAccessChecker.CheckWriteGroupAccess
type GroupAccessCheckerMockCheckWriteGroupAccessParams struct {
	ctx     context.Context
	groupId model.GroupId
}

// GroupAccessCheckerMockCheckWriteGroupAccessParamPtrs contains pointers to parameters of the GroupAccessChecker.CheckWriteGroupAccess
type GroupAccessCheckerMockCheckWriteGroupAccessParamPtrs struct {
	ctx     *context.Context
	groupId *model.GroupId
}

// GroupAccessCheckerMockCheckWriteGroupAccessResults contains results of the GroupAccessChecker.CheckWriteGroupAccess
type GroupAccessCheckerMockCheckWriteGroupAccessResults struct {
	err error
}

// GroupAccessCheckerMockCheckWriteGroupAccessOrigins contains origins of expectations of the GroupAccessChecker.CheckWriteGroupAccess
type GroupAccessCheckerMockCheckWriteGroupAccessExpectationOrigins struct {
	origin        string
	originCtx     string
	originGroupId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckWriteGroupAccess *mGroupAccessCheckerMockCheckWriteGroupAccess) Optional() *mGroupAccessCheckerMockCheckWriteGroupAccess {
	mmCheckWriteGroupAccess.optional = true
	return mmCheckWriteGroupAccess
}

// Expect sets up expected params for GroupAccessChecker.CheckWriteGroupAccess
func (mmCheckWriteGroupAccess *mGroupAccessCheckerMockCheckWriteGroupAccess) Expect(ctx context.Context, groupId model.GroupId) *mGroupAccessCheckerMockCheckWriteGroupAccess {
	if mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccess != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckWriteGroupAccess mock is already set by Set")
	}

	if mmCheckWriteGroupAccess.defaultExpectation == nil {
		mmCheckWriteGroupAccess.defaultExpectation = &GroupAccessCheckerMockCheckWriteGroupAccessExpectation{}
	}

	if mmCheckWriteGroupAccess.defaultExpectation.paramPtrs != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckWriteGroupAccess mock is already set by ExpectParams functions")
	}

	mmCheckWriteGroupAccess.defaultExpectation.params = &GroupAccessCheckerMockCheckWriteGroupAccessParams{ctx, groupId}
	mmCheckWriteGroupAccess.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckWriteGroupAccess.expectations {
		if minimock.Equal(e.params, mmCheckWriteGroupAccess.defaultExpectation.params) {
			mmCheckWriteGroupAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckWriteGroupAccess.defaultExpectation.params)
		}
	}

	return mmCheckWriteGroupAccess
}

// ExpectCtxParam1 sets up expected param ctx for GroupAccessChecker.CheckWriteGroupAccess
func (mmCheckWriteGroupAccess *mGroupAccessCheckerMockCheckWriteGroupAccess) ExpectCtxParam1(ctx context.Context) *mGroupAccessCheckerMockCheckWriteGroupAccess {
	if mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccess != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckWriteGroupAccess mock is already set by Set")
	}

	if mmCheckWriteGroupAccess.defaultExpectation == nil {
		mmCheckWriteGroupAccess.defaultExpectation = &GroupAccessCheckerMockCheckWriteGroupAccessExpectation{}
	}

	if mmCheckWriteGroupAccess.defaultExpectation.params != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckWriteGroupAccess mock is already set by Expect")
	}

	if mmCheckWriteGroupAccess.defaultExpectation.paramPtrs == nil {
		mmCheckWriteGroupAccess.defaultExpectation.paramPtrs = &GroupAccessCheckerMockCheckWriteGroupAccessParamPtrs{}
	}
	mmCheckWriteGroupAccess.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckWriteGroupAccess.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckWriteGroupAccess
}

// ExpectGroupIdParam2 sets up expected param groupId for GroupAccessChecker.CheckWriteGroupAccess
func (mmCheckWriteGroupAccess *mGroupAccessCheckerMockCheckWriteGroupAccess) ExpectGroupIdParam2(groupId model.GroupId) *mGroupAccessCheckerMockCheckWriteGroupAccess {
	if mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccess != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckWriteGroupAccess mock is already set by Set")
	}

	if mmCheckWriteGroupAccess.defaultExpectation == nil {
		mmCheckWriteGroupAccess.defaultExpectation = &GroupAccessCheckerMockCheckWriteGroupAccessExpectation{}
	}

	if mmCheckWriteGroupAccess.defaultExpectation.params != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckWriteGroupAccess mock is already set by Expect")
	}

	if mmCheckWriteGroupAccess.defaultExpectation.paramPtrs == nil {
		mmCheckWriteGroupAccess.defaultExpectation.paramPtrs = &GroupAccessCheckerMockCheckWriteGroupAccessParamPtrs{}
	}
	mmCheckWriteGroupAccess.defaultExpectation.paramPtrs.groupId = &groupId
	mmCheckWriteGroupAccess.defaultExpectation.expectationOrigins.originGroupId = minimock.CallerInfo(1)

	return mmCheckWriteGroupAccess
}

// Inspect accepts an inspector function that has same arguments as the GroupAccessChecker.CheckWriteGroupAccess
func (mmCheckWriteGroupAccess *mGroupAccessCheckerMockCheckWriteGroupAccess) Inspect(f func(ctx context.Context, groupId model.GroupId)) *mGroupAccessCheckerMockCheckWriteGroupAccess {
	if mmCheckWriteGroupAccess.mock.inspectFuncCheckWriteGroupAccess != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("Inspect function is already set for GroupAccessCheckerMock.CheckWriteGroupAccess")
	}

	mmCheckWriteGroupAccess.mock.inspectFuncCheckWriteGroupAccess = f

	return mmCheckWriteGroupAccess
}

// Return sets up results that will be returned by GroupAccessChecker.CheckWriteGroupAccess
func (mmCheckWriteGroupAccess *mGroupAccessCheckerMockCheckWriteGroupAccess) Return(err error) *GroupAccessCheckerMock {
	if mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccess != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckWriteGroupAccess mock is already set by Set")
	}

	if mmCheckWriteGroupAccess.defaultExpectation == nil {
		mmCheckWriteGroupAccess.defaultExpectation = &GroupAccessCheckerMockCheckWriteGroupAccessExpectation{mock: mmCheckWriteGroupAccess.mock}
	}
	mmCheckWriteGroupAccess.defaultExpectation.results = &GroupAccessCheckerMockCheckWriteGroupAccessResults{err}
	mmCheckWriteGroupAccess.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckWriteGroupAccess.mock
}

// Set uses given function f to mock the GroupAccessChecker.CheckWriteGroupAccess method
func (mmCheckWriteGroupAccess *mGroupAccessCheckerMockCheckWriteGroupAccess) Set(f func(ctx context.Context, groupId model.GroupId) (err error)) *GroupAccessCheckerMock {
	if mmCheckWriteGroupAccess.defaultExpectation != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("Default expectation is already set for the GroupAccessChecker.CheckWriteGroupAccess method")
	}

	if len(mmCheckWriteGroupAccess.expectations) > 0 {
		mmCheckWriteGroupAccess.mock.t.Fatalf("Some expectations are already set for the GroupAccessChecker.CheckWriteGroupAccess method")
	}

	mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccess = f
	mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccessOrigin = minimock.CallerInfo(1)
	return mmCheckWriteGroupAccess.mock
}

// When sets expectation for the GroupAccessChecker.CheckWriteGroupAccess which will trigger the result defined by the following
// Then helper
func (mmCheckWriteGroupAccess *mGroupAccessCheckerMockCheckWriteGroupAccess) When(ctx context.Context, groupId model.GroupId) *GroupAccessCheckerMockCheckWriteGroupAccessExpectation {
	if mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccess != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessCheckerMock.CheckWriteGroupAccess mock is already set by Set")
	}

	expectation := &GroupAccessCheckerMockCheckWriteGroupAccessExpectation{
		mock:               mmCheckWriteGroupAccess.mock,
		params:             &GroupAccessCheckerMockCheckWriteGroupAccessParams{ctx, groupId},
		expectationOrigins: GroupAccessCheckerMockCheckWriteGroupAccessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckWriteGroupAccess.expectations = append(mmCheckWriteGroupAccess.expectations, expectation)
	return expectation
}

// Then sets up GroupAccessChecker.CheckWriteGroupAccess return parameters for the expectation previously defined by the When method
func (e *GroupAccessCheckerMockCheckWriteGroupAccessExpectation) Then(err error) *GroupAccessCheckerMock {
	e.results = &GroupAccessCheckerMockCheckWriteGroupAccessResults{err}
	return e.mock
}

// Times sets number of times GroupAccessChecker.CheckWriteGroupAccess should be invoked
func (mmCheckWriteGroupAccess *mGroupAccessCheckerMockCheckWriteGroupAccess) Times(n uint64) *mGroupAccessCheckerMockCheckWriteGroupAccess {
	if n == 0 {
		mmCheckWriteGroupAccess.mock.t.Fatalf("Times of GroupAccessCheckerMock.CheckWriteGroupAccess mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckWriteGroupAccess.expectedInvocations, n)
	mmCheckWriteGroupAccess.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckWriteGroupAccess
}

func (mmCheckWriteGroupAccess *mGroupAccessCheckerMockCheckWriteGroupAccess) invocationsDone() bool {
	if len(mmCheckWriteGroupAccess.expectations) == 0 && mmCheckWriteGroupAccess.defaultExpectation == nil && mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccess == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckWriteGroupAccess.mock.afterCheckWriteGroupAccessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckWriteGroupAccess.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckWriteGroupAccess implements mm_module.GroupAccessChecker
func (mmCheckWriteGroupAccess *GroupAccessCheckerMock) CheckWriteGroupAccess(ctx context.Context, groupId model.GroupId) (err error) {
	mm_atomic.AddUint64(&mmCheckWriteGroupAccess.beforeCheckWriteGroupAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckWriteGroupAccess.afterCheckWriteGroupAccessCounter, 1)

	mmCheckWriteGroupAccess.t.Helper()

	if mmCheckWriteGroupAccess.inspectFuncCheckWriteGroupAccess != nil {
		mmCheckWriteGroupAccess.inspectFuncCheckWriteGroupAccess(ctx, groupId)
	}

	mm_params := GroupAccessCheckerMockCheckWriteGroupAccessParams{ctx, groupId}

	// Record call args
	mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.mutex.Lock()
	mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.callArgs = append(mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.callArgs, &mm_params)
	mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.mutex.Unlock()

	for _, e := range mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation.params
		mm_want_ptrs := mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation.paramPtrs

		mm_got := GroupAccessCheckerMockCheckWriteGroupAccessParams{ctx, groupId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckWriteGroupAccess.t.Errorf("GroupAccessCheckerMock.CheckWriteGroupAccess got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.groupId != nil && !minimock.Equal(*mm_want_ptrs.groupId, mm_got.groupId) {
				mmCheckWriteGroupAccess.t.Errorf("GroupAccessCheckerMock.CheckWriteGroupAccess got unexpected parameter groupId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation.expectationOrigins.originGroupId, *mm_want_ptrs.groupId, mm_got.groupId, minimock.Diff(*mm_want_ptrs.groupId, mm_got.groupId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckWriteGroupAccess.t.Errorf("GroupAccessCheckerMock.CheckWriteGroupAccess got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckWriteGroupAccess.t.Fatal("No results are set for the GroupAccessCheckerMock.CheckWriteGroupAccess")
		}
		return (*mm_results).err
	}
	if mmCheckWriteGroupAccess.funcCheckWriteGroupAccess != nil {
		return mmCheckWriteGroupAccess.funcCheckWriteGroupAccess(ctx, groupId)
	}
	mmCheckWriteGroupAccess.t.Fatalf("Unexpected call to GroupAccessCheckerMock.CheckWriteGroupAccess. %v %v", ctx, groupId)
	return
}

// CheckWriteGroupAccessAfterCounter returns a count of finished GroupAccessCheckerMock.CheckWriteGroupAccess invocations
func (mmCheckWriteGroupAccess *GroupAccessCheckerMock) CheckWriteGroupAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckWriteGroupAccess.afterCheckWriteGroupAccessCounter)
}

// CheckWriteGroupAccessBeforeCounter returns a count of GroupAccessCheckerMock.CheckWriteGroupAccess invocations
func (mmCheckWriteGroupAccess *GroupAccessCheckerMock) CheckWriteGroupAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckWriteGroupAccess.beforeCheckWriteGroupAccessCounter)
}

// Calls returns a list of arguments used in each call to GroupAccessCheckerMock.CheckWriteGroupAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckWriteGroupAccess *mGroupAccessCheckerMockCheckWriteGroupAccess) Calls() []*GroupAccessCheckerMockCheckWriteGroupAccessParams {
	mmCheckWriteGroupAccess.mutex.RLock()

	argCopy := make([]*GroupAccessCheckerMockCheckWriteGroupAccessParams, len(mmCheckWriteGroupAccess.callArgs))
	copy(argCopy, mmCheckWriteGroupAccess.callArgs)

	mmCheckWriteGroupAccess.mutex.RUnlock()

	return argCopy
}

// MinimockCheckWriteGroupAccessDone returns true if the count of the CheckWriteGroupAccess invocations corresponds
// the number of defined expectations
func (m *GroupAccessCheckerMock) MinimockCheckWriteGroupAccessDone() bool {
	if m.CheckWriteGroupAccessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckWriteGroupAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckWriteGroupAccessMock.invocationsDone()
}

// MinimockCheckWriteGroupAccessInspect logs each unmet expectation
func (m *GroupAccessCheckerMock) MinimockCheckWriteGroupAccessInspect() {
	for _, e := range m.CheckWriteGroupAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupAccessCheckerMock.CheckWriteGroupAccess at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckWriteGroupAccessCounter := mm_atomic.LoadUint64(&m.afterCheckWriteGroupAccessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckWriteGroupAccessMock.defaultExpectation != nil && afterCheckWriteGroupAccessCounter < 1 {
		if m.CheckWriteGroupAccessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupAccessCheckerMock.CheckWriteGroupAccess at\n%s", m.CheckWriteGroupAccessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupAccessCheckerMock.CheckWriteGroupAccess at\n%s with params: %#v", m.CheckWriteGroupAccessMock.defaultExpectation.expectationOrigins.origin, *m.CheckWriteGroupAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckWriteGroupAccess != nil && afterCheckWriteGroupAccessCounter < 1 {
		m.t.Errorf("Expected call to GroupAccessCheckerMock.CheckWriteGroupAccess at\n%s", m.funcCheckWriteGroupAccessOrigin)
	}

	if !m.CheckWriteGroupAccessMock.invocationsDone() && afterCheckWriteGroupAccessCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupAccessCheckerMock.CheckWriteGroupAccess at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckWriteGroupAccessMock.expectedInvocations), m.CheckWriteGroupAccessMock.expectedInvocationsOrigin, afterCheckWriteGroupAccessCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *GroupAccessCheckerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckReadGroupAccessInspect()

			m.MinimockCheckWriteGroupAccessInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *GroupAccessCheckerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *GroupAccessCheckerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckReadGroupAccessDone() &&
		m.MinimockCheckWriteGroupAccessDone()
}
