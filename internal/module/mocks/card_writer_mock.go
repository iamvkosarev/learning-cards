// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/iamvkosarev/learning-cards/internal/module.CardWriter -o card_writer_mock.go -n CardWriterMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/iamvkosarev/learning-cards/internal/model"
)

// CardWriterMock implements mm_module.CardWriter
type CardWriterMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddCard          func(ctx context.Context, card *model.Card) (c2 model.CardId, err error)
	funcAddCardOrigin    string
	inspectFuncAddCard   func(ctx context.Context, card *model.Card)
	afterAddCardCounter  uint64
	beforeAddCardCounter uint64
	AddCardMock          mCardWriterMockAddCard

	funcDeleteCard          func(ctx context.Context, cardId model.CardId) (err error)
	funcDeleteCardOrigin    string
	inspectFuncDeleteCard   func(ctx context.Context, cardId model.CardId)
	afterDeleteCardCounter  uint64
	beforeDeleteCardCounter uint64
	DeleteCardMock          mCardWriterMockDeleteCard

	funcUpdateCard          func(ctx context.Context, card *model.Card) (err error)
	funcUpdateCardOrigin    string
	inspectFuncUpdateCard   func(ctx context.Context, card *model.Card)
	afterUpdateCardCounter  uint64
	beforeUpdateCardCounter uint64
	UpdateCardMock          mCardWriterMockUpdateCard
}

// NewCardWriterMock returns a mock for mm_module.CardWriter
func NewCardWriterMock(t minimock.Tester) *CardWriterMock {
	m := &CardWriterMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddCardMock = mCardWriterMockAddCard{mock: m}
	m.AddCardMock.callArgs = []*CardWriterMockAddCardParams{}

	m.DeleteCardMock = mCardWriterMockDeleteCard{mock: m}
	m.DeleteCardMock.callArgs = []*CardWriterMockDeleteCardParams{}

	m.UpdateCardMock = mCardWriterMockUpdateCard{mock: m}
	m.UpdateCardMock.callArgs = []*CardWriterMockUpdateCardParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCardWriterMockAddCard struct {
	optional           bool
	mock               *CardWriterMock
	defaultExpectation *CardWriterMockAddCardExpectation
	expectations       []*CardWriterMockAddCardExpectation

	callArgs []*CardWriterMockAddCardParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CardWriterMockAddCardExpectation specifies expectation struct of the CardWriter.AddCard
type CardWriterMockAddCardExpectation struct {
	mock               *CardWriterMock
	params             *CardWriterMockAddCardParams
	paramPtrs          *CardWriterMockAddCardParamPtrs
	expectationOrigins CardWriterMockAddCardExpectationOrigins
	results            *CardWriterMockAddCardResults
	returnOrigin       string
	Counter            uint64
}

// CardWriterMockAddCardParams contains parameters of the CardWriter.AddCard
type CardWriterMockAddCardParams struct {
	ctx  context.Context
	card *model.Card
}

// CardWriterMockAddCardParamPtrs contains pointers to parameters of the CardWriter.AddCard
type CardWriterMockAddCardParamPtrs struct {
	ctx  *context.Context
	card **model.Card
}

// CardWriterMockAddCardResults contains results of the CardWriter.AddCard
type CardWriterMockAddCardResults struct {
	c2  model.CardId
	err error
}

// CardWriterMockAddCardOrigins contains origins of expectations of the CardWriter.AddCard
type CardWriterMockAddCardExpectationOrigins struct {
	origin     string
	originCtx  string
	originCard string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddCard *mCardWriterMockAddCard) Optional() *mCardWriterMockAddCard {
	mmAddCard.optional = true
	return mmAddCard
}

// Expect sets up expected params for CardWriter.AddCard
func (mmAddCard *mCardWriterMockAddCard) Expect(ctx context.Context, card *model.Card) *mCardWriterMockAddCard {
	if mmAddCard.mock.funcAddCard != nil {
		mmAddCard.mock.t.Fatalf("CardWriterMock.AddCard mock is already set by Set")
	}

	if mmAddCard.defaultExpectation == nil {
		mmAddCard.defaultExpectation = &CardWriterMockAddCardExpectation{}
	}

	if mmAddCard.defaultExpectation.paramPtrs != nil {
		mmAddCard.mock.t.Fatalf("CardWriterMock.AddCard mock is already set by ExpectParams functions")
	}

	mmAddCard.defaultExpectation.params = &CardWriterMockAddCardParams{ctx, card}
	mmAddCard.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddCard.expectations {
		if minimock.Equal(e.params, mmAddCard.defaultExpectation.params) {
			mmAddCard.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddCard.defaultExpectation.params)
		}
	}

	return mmAddCard
}

// ExpectCtxParam1 sets up expected param ctx for CardWriter.AddCard
func (mmAddCard *mCardWriterMockAddCard) ExpectCtxParam1(ctx context.Context) *mCardWriterMockAddCard {
	if mmAddCard.mock.funcAddCard != nil {
		mmAddCard.mock.t.Fatalf("CardWriterMock.AddCard mock is already set by Set")
	}

	if mmAddCard.defaultExpectation == nil {
		mmAddCard.defaultExpectation = &CardWriterMockAddCardExpectation{}
	}

	if mmAddCard.defaultExpectation.params != nil {
		mmAddCard.mock.t.Fatalf("CardWriterMock.AddCard mock is already set by Expect")
	}

	if mmAddCard.defaultExpectation.paramPtrs == nil {
		mmAddCard.defaultExpectation.paramPtrs = &CardWriterMockAddCardParamPtrs{}
	}
	mmAddCard.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddCard.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddCard
}

// ExpectCardParam2 sets up expected param card for CardWriter.AddCard
func (mmAddCard *mCardWriterMockAddCard) ExpectCardParam2(card *model.Card) *mCardWriterMockAddCard {
	if mmAddCard.mock.funcAddCard != nil {
		mmAddCard.mock.t.Fatalf("CardWriterMock.AddCard mock is already set by Set")
	}

	if mmAddCard.defaultExpectation == nil {
		mmAddCard.defaultExpectation = &CardWriterMockAddCardExpectation{}
	}

	if mmAddCard.defaultExpectation.params != nil {
		mmAddCard.mock.t.Fatalf("CardWriterMock.AddCard mock is already set by Expect")
	}

	if mmAddCard.defaultExpectation.paramPtrs == nil {
		mmAddCard.defaultExpectation.paramPtrs = &CardWriterMockAddCardParamPtrs{}
	}
	mmAddCard.defaultExpectation.paramPtrs.card = &card
	mmAddCard.defaultExpectation.expectationOrigins.originCard = minimock.CallerInfo(1)

	return mmAddCard
}

// Inspect accepts an inspector function that has same arguments as the CardWriter.AddCard
func (mmAddCard *mCardWriterMockAddCard) Inspect(f func(ctx context.Context, card *model.Card)) *mCardWriterMockAddCard {
	if mmAddCard.mock.inspectFuncAddCard != nil {
		mmAddCard.mock.t.Fatalf("Inspect function is already set for CardWriterMock.AddCard")
	}

	mmAddCard.mock.inspectFuncAddCard = f

	return mmAddCard
}

// Return sets up results that will be returned by CardWriter.AddCard
func (mmAddCard *mCardWriterMockAddCard) Return(c2 model.CardId, err error) *CardWriterMock {
	if mmAddCard.mock.funcAddCard != nil {
		mmAddCard.mock.t.Fatalf("CardWriterMock.AddCard mock is already set by Set")
	}

	if mmAddCard.defaultExpectation == nil {
		mmAddCard.defaultExpectation = &CardWriterMockAddCardExpectation{mock: mmAddCard.mock}
	}
	mmAddCard.defaultExpectation.results = &CardWriterMockAddCardResults{c2, err}
	mmAddCard.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddCard.mock
}

// Set uses given function f to mock the CardWriter.AddCard method
func (mmAddCard *mCardWriterMockAddCard) Set(f func(ctx context.Context, card *model.Card) (c2 model.CardId, err error)) *CardWriterMock {
	if mmAddCard.defaultExpectation != nil {
		mmAddCard.mock.t.Fatalf("Default expectation is already set for the CardWriter.AddCard method")
	}

	if len(mmAddCard.expectations) > 0 {
		mmAddCard.mock.t.Fatalf("Some expectations are already set for the CardWriter.AddCard method")
	}

	mmAddCard.mock.funcAddCard = f
	mmAddCard.mock.funcAddCardOrigin = minimock.CallerInfo(1)
	return mmAddCard.mock
}

// When sets expectation for the CardWriter.AddCard which will trigger the result defined by the following
// Then helper
func (mmAddCard *mCardWriterMockAddCard) When(ctx context.Context, card *model.Card) *CardWriterMockAddCardExpectation {
	if mmAddCard.mock.funcAddCard != nil {
		mmAddCard.mock.t.Fatalf("CardWriterMock.AddCard mock is already set by Set")
	}

	expectation := &CardWriterMockAddCardExpectation{
		mock:               mmAddCard.mock,
		params:             &CardWriterMockAddCardParams{ctx, card},
		expectationOrigins: CardWriterMockAddCardExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddCard.expectations = append(mmAddCard.expectations, expectation)
	return expectation
}

// Then sets up CardWriter.AddCard return parameters for the expectation previously defined by the When method
func (e *CardWriterMockAddCardExpectation) Then(c2 model.CardId, err error) *CardWriterMock {
	e.results = &CardWriterMockAddCardResults{c2, err}
	return e.mock
}

// Times sets number of times CardWriter.AddCard should be invoked
func (mmAddCard *mCardWriterMockAddCard) Times(n uint64) *mCardWriterMockAddCard {
	if n == 0 {
		mmAddCard.mock.t.Fatalf("Times of CardWriterMock.AddCard mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddCard.expectedInvocations, n)
	mmAddCard.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddCard
}

func (mmAddCard *mCardWriterMockAddCard) invocationsDone() bool {
	if len(mmAddCard.expectations) == 0 && mmAddCard.defaultExpectation == nil && mmAddCard.mock.funcAddCard == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddCard.mock.afterAddCardCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddCard.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddCard implements mm_module.CardWriter
func (mmAddCard *CardWriterMock) AddCard(ctx context.Context, card *model.Card) (c2 model.CardId, err error) {
	mm_atomic.AddUint64(&mmAddCard.beforeAddCardCounter, 1)
	defer mm_atomic.AddUint64(&mmAddCard.afterAddCardCounter, 1)

	mmAddCard.t.Helper()

	if mmAddCard.inspectFuncAddCard != nil {
		mmAddCard.inspectFuncAddCard(ctx, card)
	}

	mm_params := CardWriterMockAddCardParams{ctx, card}

	// Record call args
	mmAddCard.AddCardMock.mutex.Lock()
	mmAddCard.AddCardMock.callArgs = append(mmAddCard.AddCardMock.callArgs, &mm_params)
	mmAddCard.AddCardMock.mutex.Unlock()

	for _, e := range mmAddCard.AddCardMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmAddCard.AddCardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddCard.AddCardMock.defaultExpectation.Counter, 1)
		mm_want := mmAddCard.AddCardMock.defaultExpectation.params
		mm_want_ptrs := mmAddCard.AddCardMock.defaultExpectation.paramPtrs

		mm_got := CardWriterMockAddCardParams{ctx, card}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddCard.t.Errorf("CardWriterMock.AddCard got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCard.AddCardMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.card != nil && !minimock.Equal(*mm_want_ptrs.card, mm_got.card) {
				mmAddCard.t.Errorf("CardWriterMock.AddCard got unexpected parameter card, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCard.AddCardMock.defaultExpectation.expectationOrigins.originCard, *mm_want_ptrs.card, mm_got.card, minimock.Diff(*mm_want_ptrs.card, mm_got.card))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddCard.t.Errorf("CardWriterMock.AddCard got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddCard.AddCardMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddCard.AddCardMock.defaultExpectation.results
		if mm_results == nil {
			mmAddCard.t.Fatal("No results are set for the CardWriterMock.AddCard")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmAddCard.funcAddCard != nil {
		return mmAddCard.funcAddCard(ctx, card)
	}
	mmAddCard.t.Fatalf("Unexpected call to CardWriterMock.AddCard. %v %v", ctx, card)
	return
}

// AddCardAfterCounter returns a count of finished CardWriterMock.AddCard invocations
func (mmAddCard *CardWriterMock) AddCardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCard.afterAddCardCounter)
}

// AddCardBeforeCounter returns a count of CardWriterMock.AddCard invocations
func (mmAddCard *CardWriterMock) AddCardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCard.beforeAddCardCounter)
}

// Calls returns a list of arguments used in each call to CardWriterMock.AddCard.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddCard *mCardWriterMockAddCard) Calls() []*CardWriterMockAddCardParams {
	mmAddCard.mutex.RLock()

	argCopy := make([]*CardWriterMockAddCardParams, len(mmAddCard.callArgs))
	copy(argCopy, mmAddCard.callArgs)

	mmAddCard.mutex.RUnlock()

	return argCopy
}

// MinimockAddCardDone returns true if the count of the AddCard invocations corresponds
// the number of defined expectations
func (m *CardWriterMock) MinimockAddCardDone() bool {
	if m.AddCardMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddCardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddCardMock.invocationsDone()
}

// MinimockAddCardInspect logs each unmet expectation
func (m *CardWriterMock) MinimockAddCardInspect() {
	for _, e := range m.AddCardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CardWriterMock.AddCard at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddCardCounter := mm_atomic.LoadUint64(&m.afterAddCardCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddCardMock.defaultExpectation != nil && afterAddCardCounter < 1 {
		if m.AddCardMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CardWriterMock.AddCard at\n%s", m.AddCardMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CardWriterMock.AddCard at\n%s with params: %#v", m.AddCardMock.defaultExpectation.expectationOrigins.origin, *m.AddCardMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddCard != nil && afterAddCardCounter < 1 {
		m.t.Errorf("Expected call to CardWriterMock.AddCard at\n%s", m.funcAddCardOrigin)
	}

	if !m.AddCardMock.invocationsDone() && afterAddCardCounter > 0 {
		m.t.Errorf("Expected %d calls to CardWriterMock.AddCard at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddCardMock.expectedInvocations), m.AddCardMock.expectedInvocationsOrigin, afterAddCardCounter)
	}
}

type mCardWriterMockDeleteCard struct {
	optional           bool
	mock               *CardWriterMock
	defaultExpectation *CardWriterMockDeleteCardExpectation
	expectations       []*CardWriterMockDeleteCardExpectation

	callArgs []*CardWriterMockDeleteCardParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CardWriterMockDeleteCardExpectation specifies expectation struct of the CardWriter.DeleteCard
type CardWriterMockDeleteCardExpectation struct {
	mock               *CardWriterMock
	params             *CardWriterMockDeleteCardParams
	paramPtrs          *CardWriterMockDeleteCardParamPtrs
	expectationOrigins CardWriterMockDeleteCardExpectationOrigins
	results            *CardWriterMockDeleteCardResults
	returnOrigin       string
	Counter            uint64
}

// CardWriterMockDeleteCardParams contains parameters of the CardWriter.DeleteCard
type CardWriterMockDeleteCardParams struct {
	ctx    context.Context
	cardId model.CardId
}

// CardWriterMockDeleteCardParamPtrs contains pointers to parameters of the CardWriter.DeleteCard
type CardWriterMockDeleteCardParamPtrs struct {
	ctx    *context.Context
	cardId *model.CardId
}

// CardWriterMockDeleteCardResults contains results of the CardWriter.DeleteCard
type CardWriterMockDeleteCardResults struct {
	err error
}

// CardWriterMockDeleteCardOrigins contains origins of expectations of the CardWriter.DeleteCard
type CardWriterMockDeleteCardExpectationOrigins struct {
	origin       string
	originCtx    string
	originCardId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCard *mCardWriterMockDeleteCard) Optional() *mCardWriterMockDeleteCard {
	mmDeleteCard.optional = true
	return mmDeleteCard
}

// Expect sets up expected params for CardWriter.DeleteCard
func (mmDeleteCard *mCardWriterMockDeleteCard) Expect(ctx context.Context, cardId model.CardId) *mCardWriterMockDeleteCard {
	if mmDeleteCard.mock.funcDeleteCard != nil {
		mmDeleteCard.mock.t.Fatalf("CardWriterMock.DeleteCard mock is already set by Set")
	}

	if mmDeleteCard.defaultExpectation == nil {
		mmDeleteCard.defaultExpectation = &CardWriterMockDeleteCardExpectation{}
	}

	if mmDeleteCard.defaultExpectation.paramPtrs != nil {
		mmDeleteCard.mock.t.Fatalf("CardWriterMock.DeleteCard mock is already set by ExpectParams functions")
	}

	mmDeleteCard.defaultExpectation.params = &CardWriterMockDeleteCardParams{ctx, cardId}
	mmDeleteCard.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCard.expectations {
		if minimock.Equal(e.params, mmDeleteCard.defaultExpectation.params) {
			mmDeleteCard.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCard.defaultExpectation.params)
		}
	}

	return mmDeleteCard
}

// ExpectCtxParam1 sets up expected param ctx for CardWriter.DeleteCard
func (mmDeleteCard *mCardWriterMockDeleteCard) ExpectCtxParam1(ctx context.Context) *mCardWriterMockDeleteCard {
	if mmDeleteCard.mock.funcDeleteCard != nil {
		mmDeleteCard.mock.t.Fatalf("CardWriterMock.DeleteCard mock is already set by Set")
	}

	if mmDeleteCard.defaultExpectation == nil {
		mmDeleteCard.defaultExpectation = &CardWriterMockDeleteCardExpectation{}
	}

	if mmDeleteCard.defaultExpectation.params != nil {
		mmDeleteCard.mock.t.Fatalf("CardWriterMock.DeleteCard mock is already set by Expect")
	}

	if mmDeleteCard.defaultExpectation.paramPtrs == nil {
		mmDeleteCard.defaultExpectation.paramPtrs = &CardWriterMockDeleteCardParamPtrs{}
	}
	mmDeleteCard.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCard.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCard
}

// ExpectCardIdParam2 sets up expected param cardId for CardWriter.DeleteCard
func (mmDeleteCard *mCardWriterMockDeleteCard) ExpectCardIdParam2(cardId model.CardId) *mCardWriterMockDeleteCard {
	if mmDeleteCard.mock.funcDeleteCard != nil {
		mmDeleteCard.mock.t.Fatalf("CardWriterMock.DeleteCard mock is already set by Set")
	}

	if mmDeleteCard.defaultExpectation == nil {
		mmDeleteCard.defaultExpectation = &CardWriterMockDeleteCardExpectation{}
	}

	if mmDeleteCard.defaultExpectation.params != nil {
		mmDeleteCard.mock.t.Fatalf("CardWriterMock.DeleteCard mock is already set by Expect")
	}

	if mmDeleteCard.defaultExpectation.paramPtrs == nil {
		mmDeleteCard.defaultExpectation.paramPtrs = &CardWriterMockDeleteCardParamPtrs{}
	}
	mmDeleteCard.defaultExpectation.paramPtrs.cardId = &cardId
	mmDeleteCard.defaultExpectation.expectationOrigins.originCardId = minimock.CallerInfo(1)

	return mmDeleteCard
}

// Inspect accepts an inspector function that has same arguments as the CardWriter.DeleteCard
func (mmDeleteCard *mCardWriterMockDeleteCard) Inspect(f func(ctx context.Context, cardId model.CardId)) *mCardWriterMockDeleteCard {
	if mmDeleteCard.mock.inspectFuncDeleteCard != nil {
		mmDeleteCard.mock.t.Fatalf("Inspect function is already set for CardWriterMock.DeleteCard")
	}

	mmDeleteCard.mock.inspectFuncDeleteCard = f

	return mmDeleteCard
}

// Return sets up results that will be returned by CardWriter.DeleteCard
func (mmDeleteCard *mCardWriterMockDeleteCard) Return(err error) *CardWriterMock {
	if mmDeleteCard.mock.funcDeleteCard != nil {
		mmDeleteCard.mock.t.Fatalf("CardWriterMock.DeleteCard mock is already set by Set")
	}

	if mmDeleteCard.defaultExpectation == nil {
		mmDeleteCard.defaultExpectation = &CardWriterMockDeleteCardExpectation{mock: mmDeleteCard.mock}
	}
	mmDeleteCard.defaultExpectation.results = &CardWriterMockDeleteCardResults{err}
	mmDeleteCard.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCard.mock
}

// Set uses given function f to mock the CardWriter.DeleteCard method
func (mmDeleteCard *mCardWriterMockDeleteCard) Set(f func(ctx context.Context, cardId model.CardId) (err error)) *CardWriterMock {
	if mmDeleteCard.defaultExpectation != nil {
		mmDeleteCard.mock.t.Fatalf("Default expectation is already set for the CardWriter.DeleteCard method")
	}

	if len(mmDeleteCard.expectations) > 0 {
		mmDeleteCard.mock.t.Fatalf("Some expectations are already set for the CardWriter.DeleteCard method")
	}

	mmDeleteCard.mock.funcDeleteCard = f
	mmDeleteCard.mock.funcDeleteCardOrigin = minimock.CallerInfo(1)
	return mmDeleteCard.mock
}

// When sets expectation for the CardWriter.DeleteCard which will trigger the result defined by the following
// Then helper
func (mmDeleteCard *mCardWriterMockDeleteCard) When(ctx context.Context, cardId model.CardId) *CardWriterMockDeleteCardExpectation {
	if mmDeleteCard.mock.funcDeleteCard != nil {
		mmDeleteCard.mock.t.Fatalf("CardWriterMock.DeleteCard mock is already set by Set")
	}

	expectation := &CardWriterMockDeleteCardExpectation{
		mock:               mmDeleteCard.mock,
		params:             &CardWriterMockDeleteCardParams{ctx, cardId},
		expectationOrigins: CardWriterMockDeleteCardExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCard.expectations = append(mmDeleteCard.expectations, expectation)
	return expectation
}

// Then sets up CardWriter.DeleteCard return parameters for the expectation previously defined by the When method
func (e *CardWriterMockDeleteCardExpectation) Then(err error) *CardWriterMock {
	e.results = &CardWriterMockDeleteCardResults{err}
	return e.mock
}

// Times sets number of times CardWriter.DeleteCard should be invoked
func (mmDeleteCard *mCardWriterMockDeleteCard) Times(n uint64) *mCardWriterMockDeleteCard {
	if n == 0 {
		mmDeleteCard.mock.t.Fatalf("Times of CardWriterMock.DeleteCard mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCard.expectedInvocations, n)
	mmDeleteCard.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCard
}

func (mmDeleteCard *mCardWriterMockDeleteCard) invocationsDone() bool {
	if len(mmDeleteCard.expectations) == 0 && mmDeleteCard.defaultExpectation == nil && mmDeleteCard.mock.funcDeleteCard == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCard.mock.afterDeleteCardCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCard.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCard implements mm_module.CardWriter
func (mmDeleteCard *CardWriterMock) DeleteCard(ctx context.Context, cardId model.CardId) (err error) {
	mm_atomic.AddUint64(&mmDeleteCard.beforeDeleteCardCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCard.afterDeleteCardCounter, 1)

	mmDeleteCard.t.Helper()

	if mmDeleteCard.inspectFuncDeleteCard != nil {
		mmDeleteCard.inspectFuncDeleteCard(ctx, cardId)
	}

	mm_params := CardWriterMockDeleteCardParams{ctx, cardId}

	// Record call args
	mmDeleteCard.DeleteCardMock.mutex.Lock()
	mmDeleteCard.DeleteCardMock.callArgs = append(mmDeleteCard.DeleteCardMock.callArgs, &mm_params)
	mmDeleteCard.DeleteCardMock.mutex.Unlock()

	for _, e := range mmDeleteCard.DeleteCardMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCard.DeleteCardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCard.DeleteCardMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCard.DeleteCardMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCard.DeleteCardMock.defaultExpectation.paramPtrs

		mm_got := CardWriterMockDeleteCardParams{ctx, cardId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCard.t.Errorf("CardWriterMock.DeleteCard got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCard.DeleteCardMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cardId != nil && !minimock.Equal(*mm_want_ptrs.cardId, mm_got.cardId) {
				mmDeleteCard.t.Errorf("CardWriterMock.DeleteCard got unexpected parameter cardId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCard.DeleteCardMock.defaultExpectation.expectationOrigins.originCardId, *mm_want_ptrs.cardId, mm_got.cardId, minimock.Diff(*mm_want_ptrs.cardId, mm_got.cardId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCard.t.Errorf("CardWriterMock.DeleteCard got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCard.DeleteCardMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCard.DeleteCardMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCard.t.Fatal("No results are set for the CardWriterMock.DeleteCard")
		}
		return (*mm_results).err
	}
	if mmDeleteCard.funcDeleteCard != nil {
		return mmDeleteCard.funcDeleteCard(ctx, cardId)
	}
	mmDeleteCard.t.Fatalf("Unexpected call to CardWriterMock.DeleteCard. %v %v", ctx, cardId)
	return
}

// DeleteCardAfterCounter returns a count of finished CardWriterMock.DeleteCard invocations
func (mmDeleteCard *CardWriterMock) DeleteCardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCard.afterDeleteCardCounter)
}

// DeleteCardBeforeCounter returns a count of CardWriterMock.DeleteCard invocations
func (mmDeleteCard *CardWriterMock) DeleteCardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCard.beforeDeleteCardCounter)
}

// Calls returns a list of arguments used in each call to CardWriterMock.DeleteCard.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCard *mCardWriterMockDeleteCard) Calls() []*CardWriterMockDeleteCardParams {
	mmDeleteCard.mutex.RLock()

	argCopy := make([]*CardWriterMockDeleteCardParams, len(mmDeleteCard.callArgs))
	copy(argCopy, mmDeleteCard.callArgs)

	mmDeleteCard.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCardDone returns true if the count of the DeleteCard invocations corresponds
// the number of defined expectations
func (m *CardWriterMock) MinimockDeleteCardDone() bool {
	if m.DeleteCardMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCardMock.invocationsDone()
}

// MinimockDeleteCardInspect logs each unmet expectation
func (m *CardWriterMock) MinimockDeleteCardInspect() {
	for _, e := range m.DeleteCardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CardWriterMock.DeleteCard at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCardCounter := mm_atomic.LoadUint64(&m.afterDeleteCardCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCardMock.defaultExpectation != nil && afterDeleteCardCounter < 1 {
		if m.DeleteCardMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CardWriterMock.DeleteCard at\n%s", m.DeleteCardMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CardWriterMock.DeleteCard at\n%s with params: %#v", m.DeleteCardMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCardMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCard != nil && afterDeleteCardCounter < 1 {
		m.t.Errorf("Expected call to CardWriterMock.DeleteCard at\n%s", m.funcDeleteCardOrigin)
	}

	if !m.DeleteCardMock.invocationsDone() && afterDeleteCardCounter > 0 {
		m.t.Errorf("Expected %d calls to CardWriterMock.DeleteCard at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCardMock.expectedInvocations), m.DeleteCardMock.expectedInvocationsOrigin, afterDeleteCardCounter)
	}
}

type mCardWriterMockUpdateCard struct {
	optional           bool
	mock               *CardWriterMock
	defaultExpectation *CardWriterMockUpdateCardExpectation
	expectations       []*CardWriterMockUpdateCardExpectation

	callArgs []*CardWriterMockUpdateCardParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CardWriterMockUpdateCardExpectation specifies expectation struct of the CardWriter.UpdateCard
type CardWriterMockUpdateCardExpectation struct {
	mock               *CardWriterMock
	params             *CardWriterMockUpdateCardParams
	paramPtrs          *CardWriterMockUpdateCardParamPtrs
	expectationOrigins CardWriterMockUpdateCardExpectationOrigins
	results            *CardWriterMockUpdateCardResults
	returnOrigin       string
	Counter            uint64
}

// CardWriterMockUpdateCardParams contains parameters of the CardWriter.UpdateCard
type CardWriterMockUpdateCardParams struct {
	ctx  context.Context
	card *model.Card
}

// CardWriterMockUpdateCardParamPtrs contains pointers to parameters of the CardWriter.UpdateCard
type CardWriterMockUpdateCardParamPtrs struct {
	ctx  *context.Context
	card **model.Card
}

// CardWriterMockUpdateCardResults contains results of the CardWriter.UpdateCard
type CardWriterMockUpdateCardResults struct {
	err error
}

// CardWriterMockUpdateCardOrigins contains origins of expectations of the CardWriter.UpdateCard
type CardWriterMockUpdateCardExpectationOrigins struct {
	origin     string
	originCtx  string
	originCard string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateCard *mCardWriterMockUpdateCard) Optional() *mCardWriterMockUpdateCard {
	mmUpdateCard.optional = true
	return mmUpdateCard
}

// Expect sets up expected params for CardWriter.UpdateCard
func (mmUpdateCard *mCardWriterMockUpdateCard) Expect(ctx context.Context, card *model.Card) *mCardWriterMockUpdateCard {
	if mmUpdateCard.mock.funcUpdateCard != nil {
		mmUpdateCard.mock.t.Fatalf("CardWriterMock.UpdateCard mock is already set by Set")
	}

	if mmUpdateCard.defaultExpectation == nil {
		mmUpdateCard.defaultExpectation = &CardWriterMockUpdateCardExpectation{}
	}

	if mmUpdateCard.defaultExpectation.paramPtrs != nil {
		mmUpdateCard.mock.t.Fatalf("CardWriterMock.UpdateCard mock is already set by ExpectParams functions")
	}

	mmUpdateCard.defaultExpectation.params = &CardWriterMockUpdateCardParams{ctx, card}
	mmUpdateCard.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateCard.expectations {
		if minimock.Equal(e.params, mmUpdateCard.defaultExpectation.params) {
			mmUpdateCard.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCard.defaultExpectation.params)
		}
	}

	return mmUpdateCard
}

// ExpectCtxParam1 sets up expected param ctx for CardWriter.UpdateCard
func (mmUpdateCard *mCardWriterMockUpdateCard) ExpectCtxParam1(ctx context.Context) *mCardWriterMockUpdateCard {
	if mmUpdateCard.mock.funcUpdateCard != nil {
		mmUpdateCard.mock.t.Fatalf("CardWriterMock.UpdateCard mock is already set by Set")
	}

	if mmUpdateCard.defaultExpectation == nil {
		mmUpdateCard.defaultExpectation = &CardWriterMockUpdateCardExpectation{}
	}

	if mmUpdateCard.defaultExpectation.params != nil {
		mmUpdateCard.mock.t.Fatalf("CardWriterMock.UpdateCard mock is already set by Expect")
	}

	if mmUpdateCard.defaultExpectation.paramPtrs == nil {
		mmUpdateCard.defaultExpectation.paramPtrs = &CardWriterMockUpdateCardParamPtrs{}
	}
	mmUpdateCard.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateCard.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateCard
}

// ExpectCardParam2 sets up expected param card for CardWriter.UpdateCard
func (mmUpdateCard *mCardWriterMockUpdateCard) ExpectCardParam2(card *model.Card) *mCardWriterMockUpdateCard {
	if mmUpdateCard.mock.funcUpdateCard != nil {
		mmUpdateCard.mock.t.Fatalf("CardWriterMock.UpdateCard mock is already set by Set")
	}

	if mmUpdateCard.defaultExpectation == nil {
		mmUpdateCard.defaultExpectation = &CardWriterMockUpdateCardExpectation{}
	}

	if mmUpdateCard.defaultExpectation.params != nil {
		mmUpdateCard.mock.t.Fatalf("CardWriterMock.UpdateCard mock is already set by Expect")
	}

	if mmUpdateCard.defaultExpectation.paramPtrs == nil {
		mmUpdateCard.defaultExpectation.paramPtrs = &CardWriterMockUpdateCardParamPtrs{}
	}
	mmUpdateCard.defaultExpectation.paramPtrs.card = &card
	mmUpdateCard.defaultExpectation.expectationOrigins.originCard = minimock.CallerInfo(1)

	return mmUpdateCard
}

// Inspect accepts an inspector function that has same arguments as the CardWriter.UpdateCard
func (mmUpdateCard *mCardWriterMockUpdateCard) Inspect(f func(ctx context.Context, card *model.Card)) *mCardWriterMockUpdateCard {
	if mmUpdateCard.mock.inspectFuncUpdateCard != nil {
		mmUpdateCard.mock.t.Fatalf("Inspect function is already set for CardWriterMock.UpdateCard")
	}

	mmUpdateCard.mock.inspectFuncUpdateCard = f

	return mmUpdateCard
}

// Return sets up results that will be returned by CardWriter.UpdateCard
func (mmUpdateCard *mCardWriterMockUpdateCard) Return(err error) *CardWriterMock {
	if mmUpdateCard.mock.funcUpdateCard != nil {
		mmUpdateCard.mock.t.Fatalf("CardWriterMock.UpdateCard mock is already set by Set")
	}

	if mmUpdateCard.defaultExpectation == nil {
		mmUpdateCard.defaultExpectation = &CardWriterMockUpdateCardExpectation{mock: mmUpdateCard.mock}
	}
	mmUpdateCard.defaultExpectation.results = &CardWriterMockUpdateCardResults{err}
	mmUpdateCard.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateCard.mock
}

// Set uses given function f to mock the CardWriter.UpdateCard method
func (mmUpdateCard *mCardWriterMockUpdateCard) Set(f func(ctx context.Context, card *model.Card) (err error)) *CardWriterMock {
	if mmUpdateCard.defaultExpectation != nil {
		mmUpdateCard.mock.t.Fatalf("Default expectation is already set for the CardWriter.UpdateCard method")
	}

	if len(mmUpdateCard.expectations) > 0 {
		mmUpdateCard.mock.t.Fatalf("Some expectations are already set for the CardWriter.UpdateCard method")
	}

	mmUpdateCard.mock.funcUpdateCard = f
	mmUpdateCard.mock.funcUpdateCardOrigin = minimock.CallerInfo(1)
	return mmUpdateCard.mock
}

// When sets expectation for the CardWriter.UpdateCard which will trigger the result defined by the following
// Then helper
func (mmUpdateCard *mCardWriterMockUpdateCard) When(ctx context.Context, card *model.Card) *CardWriterMockUpdateCardExpectation {
	if mmUpdateCard.mock.funcUpdateCard != nil {
		mmUpdateCard.mock.t.Fatalf("CardWriterMock.UpdateCard mock is already set by Set")
	}

	expectation := &CardWriterMockUpdateCardExpectation{
		mock:               mmUpdateCard.mock,
		params:             &CardWriterMockUpdateCardParams{ctx, card},
		expectationOrigins: CardWriterMockUpdateCardExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateCard.expectations = append(mmUpdateCard.expectations, expectation)
	return expectation
}

// Then sets up CardWriter.UpdateCard return parameters for the expectation previously defined by the When method
func (e *CardWriterMockUpdateCardExpectation) Then(err error) *CardWriterMock {
	e.results = &CardWriterMockUpdateCardResults{err}
	return e.mock
}

// Times sets number of times CardWriter.UpdateCard should be invoked
func (mmUpdateCard *mCardWriterMockUpdateCard) Times(n uint64) *mCardWriterMockUpdateCard {
	if n == 0 {
		mmUpdateCard.mock.t.Fatalf("Times of CardWriterMock.UpdateCard mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateCard.expectedInvocations, n)
	mmUpdateCard.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateCard
}

func (mmUpdateCard *mCardWriterMockUpdateCard) invocationsDone() bool {
	if len(mmUpdateCard.expectations) == 0 && mmUpdateCard.defaultExpectation == nil && mmUpdateCard.mock.funcUpdateCard == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateCard.mock.afterUpdateCardCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateCard.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateCard implements mm_module.CardWriter
func (mmUpdateCard *CardWriterMock) UpdateCard(ctx context.Context, card *model.Card) (err error) {
	mm_atomic.AddUint64(&mmUpdateCard.beforeUpdateCardCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCard.afterUpdateCardCounter, 1)

	mmUpdateCard.t.Helper()

	if mmUpdateCard.inspectFuncUpdateCard != nil {
		mmUpdateCard.inspectFuncUpdateCard(ctx, card)
	}

	mm_params := CardWriterMockUpdateCardParams{ctx, card}

	// Record call args
	mmUpdateCard.UpdateCardMock.mutex.Lock()
	mmUpdateCard.UpdateCardMock.callArgs = append(mmUpdateCard.UpdateCardMock.callArgs, &mm_params)
	mmUpdateCard.UpdateCardMock.mutex.Unlock()

	for _, e := range mmUpdateCard.UpdateCardMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateCard.UpdateCardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCard.UpdateCardMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCard.UpdateCardMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateCard.UpdateCardMock.defaultExpectation.paramPtrs

		mm_got := CardWriterMockUpdateCardParams{ctx, card}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateCard.t.Errorf("CardWriterMock.UpdateCard got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCard.UpdateCardMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.card != nil && !minimock.Equal(*mm_want_ptrs.card, mm_got.card) {
				mmUpdateCard.t.Errorf("CardWriterMock.UpdateCard got unexpected parameter card, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCard.UpdateCardMock.defaultExpectation.expectationOrigins.originCard, *mm_want_ptrs.card, mm_got.card, minimock.Diff(*mm_want_ptrs.card, mm_got.card))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCard.t.Errorf("CardWriterMock.UpdateCard got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateCard.UpdateCardMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCard.UpdateCardMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCard.t.Fatal("No results are set for the CardWriterMock.UpdateCard")
		}
		return (*mm_results).err
	}
	if mmUpdateCard.funcUpdateCard != nil {
		return mmUpdateCard.funcUpdateCard(ctx, card)
	}
	mmUpdateCard.t.Fatalf("Unexpected call to CardWriterMock.UpdateCard. %v %v", ctx, card)
	return
}

// UpdateCardAfterCounter returns a count of finished CardWriterMock.UpdateCard invocations
func (mmUpdateCard *CardWriterMock) UpdateCardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCard.afterUpdateCardCounter)
}

// UpdateCardBeforeCounter returns a count of CardWriterMock.UpdateCard invocations
func (mmUpdateCard *CardWriterMock) UpdateCardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCard.beforeUpdateCardCounter)
}

// Calls returns a list of arguments used in each call to CardWriterMock.UpdateCard.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCard *mCardWriterMockUpdateCard) Calls() []*CardWriterMockUpdateCardParams {
	mmUpdateCard.mutex.RLock()

	argCopy := make([]*CardWriterMockUpdateCardParams, len(mmUpdateCard.callArgs))
	copy(argCopy, mmUpdateCard.callArgs)

	mmUpdateCard.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCardDone returns true if the count of the UpdateCard invocations corresponds
// the number of defined expectations
func (m *CardWriterMock) MinimockUpdateCardDone() bool {
	if m.UpdateCardMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateCardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateCardMock.invocationsDone()
}

// MinimockUpdateCardInspect logs each unmet expectation
func (m *CardWriterMock) MinimockUpdateCardInspect() {
	for _, e := range m.UpdateCardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CardWriterMock.UpdateCard at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCardCounter := mm_atomic.LoadUint64(&m.afterUpdateCardCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCardMock.defaultExpectation != nil && afterUpdateCardCounter < 1 {
		if m.UpdateCardMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CardWriterMock.UpdateCard at\n%s", m.UpdateCardMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CardWriterMock.UpdateCard at\n%s with params: %#v", m.UpdateCardMock.defaultExpectation.expectationOrigins.origin, *m.UpdateCardMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCard != nil && afterUpdateCardCounter < 1 {
		m.t.Errorf("Expected call to CardWriterMock.UpdateCard at\n%s", m.funcUpdateCardOrigin)
	}

	if !m.UpdateCardMock.invocationsDone() && afterUpdateCardCounter > 0 {
		m.t.Errorf("Expected %d calls to CardWriterMock.UpdateCard at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateCardMock.expectedInvocations), m.UpdateCardMock.expectedInvocationsOrigin, afterUpdateCardCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CardWriterMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddCardInspect()

			m.MinimockDeleteCardInspect()

			m.MinimockUpdateCardInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CardWriterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CardWriterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddCardDone() &&
		m.MinimockDeleteCardDone() &&
		m.MinimockUpdateCardDone()
}
