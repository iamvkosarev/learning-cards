// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/iamvkosarev/learning-cards/internal/service.GroupAccessChecker -o group_access_checker_mock.go -n GroupAccessChecker -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/iamvkosarev/learning-cards/internal/domain/entity"
)

// GroupAccessChecker implements mm_service.GroupAccessChecker
type GroupAccessChecker struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckReadGroupAccess          func(ctx context.Context, groupId entity.GroupId) (err error)
	funcCheckReadGroupAccessOrigin    string
	inspectFuncCheckReadGroupAccess   func(ctx context.Context, groupId entity.GroupId)
	afterCheckReadGroupAccessCounter  uint64
	beforeCheckReadGroupAccessCounter uint64
	CheckReadGroupAccessMock          mGroupAccessCheckerCheckReadGroupAccess

	funcCheckWriteGroupAccess          func(ctx context.Context, groupId entity.GroupId) (err error)
	funcCheckWriteGroupAccessOrigin    string
	inspectFuncCheckWriteGroupAccess   func(ctx context.Context, groupId entity.GroupId)
	afterCheckWriteGroupAccessCounter  uint64
	beforeCheckWriteGroupAccessCounter uint64
	CheckWriteGroupAccessMock          mGroupAccessCheckerCheckWriteGroupAccess
}

// NewGroupAccessChecker returns a mock for mm_service.GroupAccessChecker
func NewGroupAccessChecker(t minimock.Tester) *GroupAccessChecker {
	m := &GroupAccessChecker{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckReadGroupAccessMock = mGroupAccessCheckerCheckReadGroupAccess{mock: m}
	m.CheckReadGroupAccessMock.callArgs = []*GroupAccessCheckerCheckReadGroupAccessParams{}

	m.CheckWriteGroupAccessMock = mGroupAccessCheckerCheckWriteGroupAccess{mock: m}
	m.CheckWriteGroupAccessMock.callArgs = []*GroupAccessCheckerCheckWriteGroupAccessParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mGroupAccessCheckerCheckReadGroupAccess struct {
	optional           bool
	mock               *GroupAccessChecker
	defaultExpectation *GroupAccessCheckerCheckReadGroupAccessExpectation
	expectations       []*GroupAccessCheckerCheckReadGroupAccessExpectation

	callArgs []*GroupAccessCheckerCheckReadGroupAccessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupAccessCheckerCheckReadGroupAccessExpectation specifies expectation struct of the GroupAccessChecker.CheckReadGroupAccess
type GroupAccessCheckerCheckReadGroupAccessExpectation struct {
	mock               *GroupAccessChecker
	params             *GroupAccessCheckerCheckReadGroupAccessParams
	paramPtrs          *GroupAccessCheckerCheckReadGroupAccessParamPtrs
	expectationOrigins GroupAccessCheckerCheckReadGroupAccessExpectationOrigins
	results            *GroupAccessCheckerCheckReadGroupAccessResults
	returnOrigin       string
	Counter            uint64
}

// GroupAccessCheckerCheckReadGroupAccessParams contains parameters of the GroupAccessChecker.CheckReadGroupAccess
type GroupAccessCheckerCheckReadGroupAccessParams struct {
	ctx     context.Context
	groupId entity.GroupId
}

// GroupAccessCheckerCheckReadGroupAccessParamPtrs contains pointers to parameters of the GroupAccessChecker.CheckReadGroupAccess
type GroupAccessCheckerCheckReadGroupAccessParamPtrs struct {
	ctx     *context.Context
	groupId *entity.GroupId
}

// GroupAccessCheckerCheckReadGroupAccessResults contains results of the GroupAccessChecker.CheckReadGroupAccess
type GroupAccessCheckerCheckReadGroupAccessResults struct {
	err error
}

// GroupAccessCheckerCheckReadGroupAccessOrigins contains origins of expectations of the GroupAccessChecker.CheckReadGroupAccess
type GroupAccessCheckerCheckReadGroupAccessExpectationOrigins struct {
	origin        string
	originCtx     string
	originGroupId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckReadGroupAccess *mGroupAccessCheckerCheckReadGroupAccess) Optional() *mGroupAccessCheckerCheckReadGroupAccess {
	mmCheckReadGroupAccess.optional = true
	return mmCheckReadGroupAccess
}

// Expect sets up expected params for GroupAccessChecker.CheckReadGroupAccess
func (mmCheckReadGroupAccess *mGroupAccessCheckerCheckReadGroupAccess) Expect(ctx context.Context, groupId entity.GroupId) *mGroupAccessCheckerCheckReadGroupAccess {
	if mmCheckReadGroupAccess.mock.funcCheckReadGroupAccess != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckReadGroupAccess mock is already set by Set")
	}

	if mmCheckReadGroupAccess.defaultExpectation == nil {
		mmCheckReadGroupAccess.defaultExpectation = &GroupAccessCheckerCheckReadGroupAccessExpectation{}
	}

	if mmCheckReadGroupAccess.defaultExpectation.paramPtrs != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckReadGroupAccess mock is already set by ExpectParams functions")
	}

	mmCheckReadGroupAccess.defaultExpectation.params = &GroupAccessCheckerCheckReadGroupAccessParams{ctx, groupId}
	mmCheckReadGroupAccess.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckReadGroupAccess.expectations {
		if minimock.Equal(e.params, mmCheckReadGroupAccess.defaultExpectation.params) {
			mmCheckReadGroupAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckReadGroupAccess.defaultExpectation.params)
		}
	}

	return mmCheckReadGroupAccess
}

// ExpectCtxParam1 sets up expected param ctx for GroupAccessChecker.CheckReadGroupAccess
func (mmCheckReadGroupAccess *mGroupAccessCheckerCheckReadGroupAccess) ExpectCtxParam1(ctx context.Context) *mGroupAccessCheckerCheckReadGroupAccess {
	if mmCheckReadGroupAccess.mock.funcCheckReadGroupAccess != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckReadGroupAccess mock is already set by Set")
	}

	if mmCheckReadGroupAccess.defaultExpectation == nil {
		mmCheckReadGroupAccess.defaultExpectation = &GroupAccessCheckerCheckReadGroupAccessExpectation{}
	}

	if mmCheckReadGroupAccess.defaultExpectation.params != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckReadGroupAccess mock is already set by Expect")
	}

	if mmCheckReadGroupAccess.defaultExpectation.paramPtrs == nil {
		mmCheckReadGroupAccess.defaultExpectation.paramPtrs = &GroupAccessCheckerCheckReadGroupAccessParamPtrs{}
	}
	mmCheckReadGroupAccess.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckReadGroupAccess.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckReadGroupAccess
}

// ExpectGroupIdParam2 sets up expected param groupId for GroupAccessChecker.CheckReadGroupAccess
func (mmCheckReadGroupAccess *mGroupAccessCheckerCheckReadGroupAccess) ExpectGroupIdParam2(groupId entity.GroupId) *mGroupAccessCheckerCheckReadGroupAccess {
	if mmCheckReadGroupAccess.mock.funcCheckReadGroupAccess != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckReadGroupAccess mock is already set by Set")
	}

	if mmCheckReadGroupAccess.defaultExpectation == nil {
		mmCheckReadGroupAccess.defaultExpectation = &GroupAccessCheckerCheckReadGroupAccessExpectation{}
	}

	if mmCheckReadGroupAccess.defaultExpectation.params != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckReadGroupAccess mock is already set by Expect")
	}

	if mmCheckReadGroupAccess.defaultExpectation.paramPtrs == nil {
		mmCheckReadGroupAccess.defaultExpectation.paramPtrs = &GroupAccessCheckerCheckReadGroupAccessParamPtrs{}
	}
	mmCheckReadGroupAccess.defaultExpectation.paramPtrs.groupId = &groupId
	mmCheckReadGroupAccess.defaultExpectation.expectationOrigins.originGroupId = minimock.CallerInfo(1)

	return mmCheckReadGroupAccess
}

// Inspect accepts an inspector function that has same arguments as the GroupAccessChecker.CheckReadGroupAccess
func (mmCheckReadGroupAccess *mGroupAccessCheckerCheckReadGroupAccess) Inspect(f func(ctx context.Context, groupId entity.GroupId)) *mGroupAccessCheckerCheckReadGroupAccess {
	if mmCheckReadGroupAccess.mock.inspectFuncCheckReadGroupAccess != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("Inspect function is already set for GroupAccessChecker.CheckReadGroupAccess")
	}

	mmCheckReadGroupAccess.mock.inspectFuncCheckReadGroupAccess = f

	return mmCheckReadGroupAccess
}

// Return sets up results that will be returned by GroupAccessChecker.CheckReadGroupAccess
func (mmCheckReadGroupAccess *mGroupAccessCheckerCheckReadGroupAccess) Return(err error) *GroupAccessChecker {
	if mmCheckReadGroupAccess.mock.funcCheckReadGroupAccess != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckReadGroupAccess mock is already set by Set")
	}

	if mmCheckReadGroupAccess.defaultExpectation == nil {
		mmCheckReadGroupAccess.defaultExpectation = &GroupAccessCheckerCheckReadGroupAccessExpectation{mock: mmCheckReadGroupAccess.mock}
	}
	mmCheckReadGroupAccess.defaultExpectation.results = &GroupAccessCheckerCheckReadGroupAccessResults{err}
	mmCheckReadGroupAccess.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckReadGroupAccess.mock
}

// Set uses given function f to mock the GroupAccessChecker.CheckReadGroupAccess method
func (mmCheckReadGroupAccess *mGroupAccessCheckerCheckReadGroupAccess) Set(f func(ctx context.Context, groupId entity.GroupId) (err error)) *GroupAccessChecker {
	if mmCheckReadGroupAccess.defaultExpectation != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("Default expectation is already set for the GroupAccessChecker.CheckReadGroupAccess method")
	}

	if len(mmCheckReadGroupAccess.expectations) > 0 {
		mmCheckReadGroupAccess.mock.t.Fatalf("Some expectations are already set for the GroupAccessChecker.CheckReadGroupAccess method")
	}

	mmCheckReadGroupAccess.mock.funcCheckReadGroupAccess = f
	mmCheckReadGroupAccess.mock.funcCheckReadGroupAccessOrigin = minimock.CallerInfo(1)
	return mmCheckReadGroupAccess.mock
}

// When sets expectation for the GroupAccessChecker.CheckReadGroupAccess which will trigger the result defined by the following
// Then helper
func (mmCheckReadGroupAccess *mGroupAccessCheckerCheckReadGroupAccess) When(ctx context.Context, groupId entity.GroupId) *GroupAccessCheckerCheckReadGroupAccessExpectation {
	if mmCheckReadGroupAccess.mock.funcCheckReadGroupAccess != nil {
		mmCheckReadGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckReadGroupAccess mock is already set by Set")
	}

	expectation := &GroupAccessCheckerCheckReadGroupAccessExpectation{
		mock:               mmCheckReadGroupAccess.mock,
		params:             &GroupAccessCheckerCheckReadGroupAccessParams{ctx, groupId},
		expectationOrigins: GroupAccessCheckerCheckReadGroupAccessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckReadGroupAccess.expectations = append(mmCheckReadGroupAccess.expectations, expectation)
	return expectation
}

// Then sets up GroupAccessChecker.CheckReadGroupAccess return parameters for the expectation previously defined by the When method
func (e *GroupAccessCheckerCheckReadGroupAccessExpectation) Then(err error) *GroupAccessChecker {
	e.results = &GroupAccessCheckerCheckReadGroupAccessResults{err}
	return e.mock
}

// Times sets number of times GroupAccessChecker.CheckReadGroupAccess should be invoked
func (mmCheckReadGroupAccess *mGroupAccessCheckerCheckReadGroupAccess) Times(n uint64) *mGroupAccessCheckerCheckReadGroupAccess {
	if n == 0 {
		mmCheckReadGroupAccess.mock.t.Fatalf("Times of GroupAccessChecker.CheckReadGroupAccess mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckReadGroupAccess.expectedInvocations, n)
	mmCheckReadGroupAccess.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckReadGroupAccess
}

func (mmCheckReadGroupAccess *mGroupAccessCheckerCheckReadGroupAccess) invocationsDone() bool {
	if len(mmCheckReadGroupAccess.expectations) == 0 && mmCheckReadGroupAccess.defaultExpectation == nil && mmCheckReadGroupAccess.mock.funcCheckReadGroupAccess == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckReadGroupAccess.mock.afterCheckReadGroupAccessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckReadGroupAccess.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckReadGroupAccess implements mm_service.GroupAccessChecker
func (mmCheckReadGroupAccess *GroupAccessChecker) CheckReadGroupAccess(ctx context.Context, groupId entity.GroupId) (err error) {
	mm_atomic.AddUint64(&mmCheckReadGroupAccess.beforeCheckReadGroupAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckReadGroupAccess.afterCheckReadGroupAccessCounter, 1)

	mmCheckReadGroupAccess.t.Helper()

	if mmCheckReadGroupAccess.inspectFuncCheckReadGroupAccess != nil {
		mmCheckReadGroupAccess.inspectFuncCheckReadGroupAccess(ctx, groupId)
	}

	mm_params := GroupAccessCheckerCheckReadGroupAccessParams{ctx, groupId}

	// Record call args
	mmCheckReadGroupAccess.CheckReadGroupAccessMock.mutex.Lock()
	mmCheckReadGroupAccess.CheckReadGroupAccessMock.callArgs = append(mmCheckReadGroupAccess.CheckReadGroupAccessMock.callArgs, &mm_params)
	mmCheckReadGroupAccess.CheckReadGroupAccessMock.mutex.Unlock()

	for _, e := range mmCheckReadGroupAccess.CheckReadGroupAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation.params
		mm_want_ptrs := mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation.paramPtrs

		mm_got := GroupAccessCheckerCheckReadGroupAccessParams{ctx, groupId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckReadGroupAccess.t.Errorf("GroupAccessChecker.CheckReadGroupAccess got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.groupId != nil && !minimock.Equal(*mm_want_ptrs.groupId, mm_got.groupId) {
				mmCheckReadGroupAccess.t.Errorf("GroupAccessChecker.CheckReadGroupAccess got unexpected parameter groupId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation.expectationOrigins.originGroupId, *mm_want_ptrs.groupId, mm_got.groupId, minimock.Diff(*mm_want_ptrs.groupId, mm_got.groupId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckReadGroupAccess.t.Errorf("GroupAccessChecker.CheckReadGroupAccess got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckReadGroupAccess.CheckReadGroupAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckReadGroupAccess.t.Fatal("No results are set for the GroupAccessChecker.CheckReadGroupAccess")
		}
		return (*mm_results).err
	}
	if mmCheckReadGroupAccess.funcCheckReadGroupAccess != nil {
		return mmCheckReadGroupAccess.funcCheckReadGroupAccess(ctx, groupId)
	}
	mmCheckReadGroupAccess.t.Fatalf("Unexpected call to GroupAccessChecker.CheckReadGroupAccess. %v %v", ctx, groupId)
	return
}

// CheckReadGroupAccessAfterCounter returns a count of finished GroupAccessChecker.CheckReadGroupAccess invocations
func (mmCheckReadGroupAccess *GroupAccessChecker) CheckReadGroupAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckReadGroupAccess.afterCheckReadGroupAccessCounter)
}

// CheckReadGroupAccessBeforeCounter returns a count of GroupAccessChecker.CheckReadGroupAccess invocations
func (mmCheckReadGroupAccess *GroupAccessChecker) CheckReadGroupAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckReadGroupAccess.beforeCheckReadGroupAccessCounter)
}

// Calls returns a list of arguments used in each call to GroupAccessChecker.CheckReadGroupAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckReadGroupAccess *mGroupAccessCheckerCheckReadGroupAccess) Calls() []*GroupAccessCheckerCheckReadGroupAccessParams {
	mmCheckReadGroupAccess.mutex.RLock()

	argCopy := make([]*GroupAccessCheckerCheckReadGroupAccessParams, len(mmCheckReadGroupAccess.callArgs))
	copy(argCopy, mmCheckReadGroupAccess.callArgs)

	mmCheckReadGroupAccess.mutex.RUnlock()

	return argCopy
}

// MinimockCheckReadGroupAccessDone returns true if the count of the CheckReadGroupAccess invocations corresponds
// the number of defined expectations
func (m *GroupAccessChecker) MinimockCheckReadGroupAccessDone() bool {
	if m.CheckReadGroupAccessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckReadGroupAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckReadGroupAccessMock.invocationsDone()
}

// MinimockCheckReadGroupAccessInspect logs each unmet expectation
func (m *GroupAccessChecker) MinimockCheckReadGroupAccessInspect() {
	for _, e := range m.CheckReadGroupAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupAccessChecker.CheckReadGroupAccess at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckReadGroupAccessCounter := mm_atomic.LoadUint64(&m.afterCheckReadGroupAccessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckReadGroupAccessMock.defaultExpectation != nil && afterCheckReadGroupAccessCounter < 1 {
		if m.CheckReadGroupAccessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupAccessChecker.CheckReadGroupAccess at\n%s", m.CheckReadGroupAccessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupAccessChecker.CheckReadGroupAccess at\n%s with params: %#v", m.CheckReadGroupAccessMock.defaultExpectation.expectationOrigins.origin, *m.CheckReadGroupAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckReadGroupAccess != nil && afterCheckReadGroupAccessCounter < 1 {
		m.t.Errorf("Expected call to GroupAccessChecker.CheckReadGroupAccess at\n%s", m.funcCheckReadGroupAccessOrigin)
	}

	if !m.CheckReadGroupAccessMock.invocationsDone() && afterCheckReadGroupAccessCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupAccessChecker.CheckReadGroupAccess at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckReadGroupAccessMock.expectedInvocations), m.CheckReadGroupAccessMock.expectedInvocationsOrigin, afterCheckReadGroupAccessCounter)
	}
}

type mGroupAccessCheckerCheckWriteGroupAccess struct {
	optional           bool
	mock               *GroupAccessChecker
	defaultExpectation *GroupAccessCheckerCheckWriteGroupAccessExpectation
	expectations       []*GroupAccessCheckerCheckWriteGroupAccessExpectation

	callArgs []*GroupAccessCheckerCheckWriteGroupAccessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupAccessCheckerCheckWriteGroupAccessExpectation specifies expectation struct of the GroupAccessChecker.CheckWriteGroupAccess
type GroupAccessCheckerCheckWriteGroupAccessExpectation struct {
	mock               *GroupAccessChecker
	params             *GroupAccessCheckerCheckWriteGroupAccessParams
	paramPtrs          *GroupAccessCheckerCheckWriteGroupAccessParamPtrs
	expectationOrigins GroupAccessCheckerCheckWriteGroupAccessExpectationOrigins
	results            *GroupAccessCheckerCheckWriteGroupAccessResults
	returnOrigin       string
	Counter            uint64
}

// GroupAccessCheckerCheckWriteGroupAccessParams contains parameters of the GroupAccessChecker.CheckWriteGroupAccess
type GroupAccessCheckerCheckWriteGroupAccessParams struct {
	ctx     context.Context
	groupId entity.GroupId
}

// GroupAccessCheckerCheckWriteGroupAccessParamPtrs contains pointers to parameters of the GroupAccessChecker.CheckWriteGroupAccess
type GroupAccessCheckerCheckWriteGroupAccessParamPtrs struct {
	ctx     *context.Context
	groupId *entity.GroupId
}

// GroupAccessCheckerCheckWriteGroupAccessResults contains results of the GroupAccessChecker.CheckWriteGroupAccess
type GroupAccessCheckerCheckWriteGroupAccessResults struct {
	err error
}

// GroupAccessCheckerCheckWriteGroupAccessOrigins contains origins of expectations of the GroupAccessChecker.CheckWriteGroupAccess
type GroupAccessCheckerCheckWriteGroupAccessExpectationOrigins struct {
	origin        string
	originCtx     string
	originGroupId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckWriteGroupAccess *mGroupAccessCheckerCheckWriteGroupAccess) Optional() *mGroupAccessCheckerCheckWriteGroupAccess {
	mmCheckWriteGroupAccess.optional = true
	return mmCheckWriteGroupAccess
}

// Expect sets up expected params for GroupAccessChecker.CheckWriteGroupAccess
func (mmCheckWriteGroupAccess *mGroupAccessCheckerCheckWriteGroupAccess) Expect(ctx context.Context, groupId entity.GroupId) *mGroupAccessCheckerCheckWriteGroupAccess {
	if mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccess != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckWriteGroupAccess mock is already set by Set")
	}

	if mmCheckWriteGroupAccess.defaultExpectation == nil {
		mmCheckWriteGroupAccess.defaultExpectation = &GroupAccessCheckerCheckWriteGroupAccessExpectation{}
	}

	if mmCheckWriteGroupAccess.defaultExpectation.paramPtrs != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckWriteGroupAccess mock is already set by ExpectParams functions")
	}

	mmCheckWriteGroupAccess.defaultExpectation.params = &GroupAccessCheckerCheckWriteGroupAccessParams{ctx, groupId}
	mmCheckWriteGroupAccess.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckWriteGroupAccess.expectations {
		if minimock.Equal(e.params, mmCheckWriteGroupAccess.defaultExpectation.params) {
			mmCheckWriteGroupAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckWriteGroupAccess.defaultExpectation.params)
		}
	}

	return mmCheckWriteGroupAccess
}

// ExpectCtxParam1 sets up expected param ctx for GroupAccessChecker.CheckWriteGroupAccess
func (mmCheckWriteGroupAccess *mGroupAccessCheckerCheckWriteGroupAccess) ExpectCtxParam1(ctx context.Context) *mGroupAccessCheckerCheckWriteGroupAccess {
	if mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccess != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckWriteGroupAccess mock is already set by Set")
	}

	if mmCheckWriteGroupAccess.defaultExpectation == nil {
		mmCheckWriteGroupAccess.defaultExpectation = &GroupAccessCheckerCheckWriteGroupAccessExpectation{}
	}

	if mmCheckWriteGroupAccess.defaultExpectation.params != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckWriteGroupAccess mock is already set by Expect")
	}

	if mmCheckWriteGroupAccess.defaultExpectation.paramPtrs == nil {
		mmCheckWriteGroupAccess.defaultExpectation.paramPtrs = &GroupAccessCheckerCheckWriteGroupAccessParamPtrs{}
	}
	mmCheckWriteGroupAccess.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckWriteGroupAccess.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckWriteGroupAccess
}

// ExpectGroupIdParam2 sets up expected param groupId for GroupAccessChecker.CheckWriteGroupAccess
func (mmCheckWriteGroupAccess *mGroupAccessCheckerCheckWriteGroupAccess) ExpectGroupIdParam2(groupId entity.GroupId) *mGroupAccessCheckerCheckWriteGroupAccess {
	if mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccess != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckWriteGroupAccess mock is already set by Set")
	}

	if mmCheckWriteGroupAccess.defaultExpectation == nil {
		mmCheckWriteGroupAccess.defaultExpectation = &GroupAccessCheckerCheckWriteGroupAccessExpectation{}
	}

	if mmCheckWriteGroupAccess.defaultExpectation.params != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckWriteGroupAccess mock is already set by Expect")
	}

	if mmCheckWriteGroupAccess.defaultExpectation.paramPtrs == nil {
		mmCheckWriteGroupAccess.defaultExpectation.paramPtrs = &GroupAccessCheckerCheckWriteGroupAccessParamPtrs{}
	}
	mmCheckWriteGroupAccess.defaultExpectation.paramPtrs.groupId = &groupId
	mmCheckWriteGroupAccess.defaultExpectation.expectationOrigins.originGroupId = minimock.CallerInfo(1)

	return mmCheckWriteGroupAccess
}

// Inspect accepts an inspector function that has same arguments as the GroupAccessChecker.CheckWriteGroupAccess
func (mmCheckWriteGroupAccess *mGroupAccessCheckerCheckWriteGroupAccess) Inspect(f func(ctx context.Context, groupId entity.GroupId)) *mGroupAccessCheckerCheckWriteGroupAccess {
	if mmCheckWriteGroupAccess.mock.inspectFuncCheckWriteGroupAccess != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("Inspect function is already set for GroupAccessChecker.CheckWriteGroupAccess")
	}

	mmCheckWriteGroupAccess.mock.inspectFuncCheckWriteGroupAccess = f

	return mmCheckWriteGroupAccess
}

// Return sets up results that will be returned by GroupAccessChecker.CheckWriteGroupAccess
func (mmCheckWriteGroupAccess *mGroupAccessCheckerCheckWriteGroupAccess) Return(err error) *GroupAccessChecker {
	if mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccess != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckWriteGroupAccess mock is already set by Set")
	}

	if mmCheckWriteGroupAccess.defaultExpectation == nil {
		mmCheckWriteGroupAccess.defaultExpectation = &GroupAccessCheckerCheckWriteGroupAccessExpectation{mock: mmCheckWriteGroupAccess.mock}
	}
	mmCheckWriteGroupAccess.defaultExpectation.results = &GroupAccessCheckerCheckWriteGroupAccessResults{err}
	mmCheckWriteGroupAccess.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckWriteGroupAccess.mock
}

// Set uses given function f to mock the GroupAccessChecker.CheckWriteGroupAccess method
func (mmCheckWriteGroupAccess *mGroupAccessCheckerCheckWriteGroupAccess) Set(f func(ctx context.Context, groupId entity.GroupId) (err error)) *GroupAccessChecker {
	if mmCheckWriteGroupAccess.defaultExpectation != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("Default expectation is already set for the GroupAccessChecker.CheckWriteGroupAccess method")
	}

	if len(mmCheckWriteGroupAccess.expectations) > 0 {
		mmCheckWriteGroupAccess.mock.t.Fatalf("Some expectations are already set for the GroupAccessChecker.CheckWriteGroupAccess method")
	}

	mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccess = f
	mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccessOrigin = minimock.CallerInfo(1)
	return mmCheckWriteGroupAccess.mock
}

// When sets expectation for the GroupAccessChecker.CheckWriteGroupAccess which will trigger the result defined by the following
// Then helper
func (mmCheckWriteGroupAccess *mGroupAccessCheckerCheckWriteGroupAccess) When(ctx context.Context, groupId entity.GroupId) *GroupAccessCheckerCheckWriteGroupAccessExpectation {
	if mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccess != nil {
		mmCheckWriteGroupAccess.mock.t.Fatalf("GroupAccessChecker.CheckWriteGroupAccess mock is already set by Set")
	}

	expectation := &GroupAccessCheckerCheckWriteGroupAccessExpectation{
		mock:               mmCheckWriteGroupAccess.mock,
		params:             &GroupAccessCheckerCheckWriteGroupAccessParams{ctx, groupId},
		expectationOrigins: GroupAccessCheckerCheckWriteGroupAccessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckWriteGroupAccess.expectations = append(mmCheckWriteGroupAccess.expectations, expectation)
	return expectation
}

// Then sets up GroupAccessChecker.CheckWriteGroupAccess return parameters for the expectation previously defined by the When method
func (e *GroupAccessCheckerCheckWriteGroupAccessExpectation) Then(err error) *GroupAccessChecker {
	e.results = &GroupAccessCheckerCheckWriteGroupAccessResults{err}
	return e.mock
}

// Times sets number of times GroupAccessChecker.CheckWriteGroupAccess should be invoked
func (mmCheckWriteGroupAccess *mGroupAccessCheckerCheckWriteGroupAccess) Times(n uint64) *mGroupAccessCheckerCheckWriteGroupAccess {
	if n == 0 {
		mmCheckWriteGroupAccess.mock.t.Fatalf("Times of GroupAccessChecker.CheckWriteGroupAccess mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckWriteGroupAccess.expectedInvocations, n)
	mmCheckWriteGroupAccess.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckWriteGroupAccess
}

func (mmCheckWriteGroupAccess *mGroupAccessCheckerCheckWriteGroupAccess) invocationsDone() bool {
	if len(mmCheckWriteGroupAccess.expectations) == 0 && mmCheckWriteGroupAccess.defaultExpectation == nil && mmCheckWriteGroupAccess.mock.funcCheckWriteGroupAccess == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckWriteGroupAccess.mock.afterCheckWriteGroupAccessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckWriteGroupAccess.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckWriteGroupAccess implements mm_service.GroupAccessChecker
func (mmCheckWriteGroupAccess *GroupAccessChecker) CheckWriteGroupAccess(ctx context.Context, groupId entity.GroupId) (err error) {
	mm_atomic.AddUint64(&mmCheckWriteGroupAccess.beforeCheckWriteGroupAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckWriteGroupAccess.afterCheckWriteGroupAccessCounter, 1)

	mmCheckWriteGroupAccess.t.Helper()

	if mmCheckWriteGroupAccess.inspectFuncCheckWriteGroupAccess != nil {
		mmCheckWriteGroupAccess.inspectFuncCheckWriteGroupAccess(ctx, groupId)
	}

	mm_params := GroupAccessCheckerCheckWriteGroupAccessParams{ctx, groupId}

	// Record call args
	mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.mutex.Lock()
	mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.callArgs = append(mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.callArgs, &mm_params)
	mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.mutex.Unlock()

	for _, e := range mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation.params
		mm_want_ptrs := mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation.paramPtrs

		mm_got := GroupAccessCheckerCheckWriteGroupAccessParams{ctx, groupId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckWriteGroupAccess.t.Errorf("GroupAccessChecker.CheckWriteGroupAccess got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.groupId != nil && !minimock.Equal(*mm_want_ptrs.groupId, mm_got.groupId) {
				mmCheckWriteGroupAccess.t.Errorf("GroupAccessChecker.CheckWriteGroupAccess got unexpected parameter groupId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation.expectationOrigins.originGroupId, *mm_want_ptrs.groupId, mm_got.groupId, minimock.Diff(*mm_want_ptrs.groupId, mm_got.groupId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckWriteGroupAccess.t.Errorf("GroupAccessChecker.CheckWriteGroupAccess got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckWriteGroupAccess.CheckWriteGroupAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckWriteGroupAccess.t.Fatal("No results are set for the GroupAccessChecker.CheckWriteGroupAccess")
		}
		return (*mm_results).err
	}
	if mmCheckWriteGroupAccess.funcCheckWriteGroupAccess != nil {
		return mmCheckWriteGroupAccess.funcCheckWriteGroupAccess(ctx, groupId)
	}
	mmCheckWriteGroupAccess.t.Fatalf("Unexpected call to GroupAccessChecker.CheckWriteGroupAccess. %v %v", ctx, groupId)
	return
}

// CheckWriteGroupAccessAfterCounter returns a count of finished GroupAccessChecker.CheckWriteGroupAccess invocations
func (mmCheckWriteGroupAccess *GroupAccessChecker) CheckWriteGroupAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckWriteGroupAccess.afterCheckWriteGroupAccessCounter)
}

// CheckWriteGroupAccessBeforeCounter returns a count of GroupAccessChecker.CheckWriteGroupAccess invocations
func (mmCheckWriteGroupAccess *GroupAccessChecker) CheckWriteGroupAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckWriteGroupAccess.beforeCheckWriteGroupAccessCounter)
}

// Calls returns a list of arguments used in each call to GroupAccessChecker.CheckWriteGroupAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckWriteGroupAccess *mGroupAccessCheckerCheckWriteGroupAccess) Calls() []*GroupAccessCheckerCheckWriteGroupAccessParams {
	mmCheckWriteGroupAccess.mutex.RLock()

	argCopy := make([]*GroupAccessCheckerCheckWriteGroupAccessParams, len(mmCheckWriteGroupAccess.callArgs))
	copy(argCopy, mmCheckWriteGroupAccess.callArgs)

	mmCheckWriteGroupAccess.mutex.RUnlock()

	return argCopy
}

// MinimockCheckWriteGroupAccessDone returns true if the count of the CheckWriteGroupAccess invocations corresponds
// the number of defined expectations
func (m *GroupAccessChecker) MinimockCheckWriteGroupAccessDone() bool {
	if m.CheckWriteGroupAccessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckWriteGroupAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckWriteGroupAccessMock.invocationsDone()
}

// MinimockCheckWriteGroupAccessInspect logs each unmet expectation
func (m *GroupAccessChecker) MinimockCheckWriteGroupAccessInspect() {
	for _, e := range m.CheckWriteGroupAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupAccessChecker.CheckWriteGroupAccess at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckWriteGroupAccessCounter := mm_atomic.LoadUint64(&m.afterCheckWriteGroupAccessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckWriteGroupAccessMock.defaultExpectation != nil && afterCheckWriteGroupAccessCounter < 1 {
		if m.CheckWriteGroupAccessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupAccessChecker.CheckWriteGroupAccess at\n%s", m.CheckWriteGroupAccessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupAccessChecker.CheckWriteGroupAccess at\n%s with params: %#v", m.CheckWriteGroupAccessMock.defaultExpectation.expectationOrigins.origin, *m.CheckWriteGroupAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckWriteGroupAccess != nil && afterCheckWriteGroupAccessCounter < 1 {
		m.t.Errorf("Expected call to GroupAccessChecker.CheckWriteGroupAccess at\n%s", m.funcCheckWriteGroupAccessOrigin)
	}

	if !m.CheckWriteGroupAccessMock.invocationsDone() && afterCheckWriteGroupAccessCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupAccessChecker.CheckWriteGroupAccess at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckWriteGroupAccessMock.expectedInvocations), m.CheckWriteGroupAccessMock.expectedInvocationsOrigin, afterCheckWriteGroupAccessCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *GroupAccessChecker) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckReadGroupAccessInspect()

			m.MinimockCheckWriteGroupAccessInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *GroupAccessChecker) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *GroupAccessChecker) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckReadGroupAccessDone() &&
		m.MinimockCheckWriteGroupAccessDone()
}
