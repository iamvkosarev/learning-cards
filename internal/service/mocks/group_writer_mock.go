// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/iamvkosarev/learning-cards/internal/service.GroupWriter -o group_writer_mock.go -n GroupWriterMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/iamvkosarev/learning-cards/internal/domain/entity"
)

// GroupWriterMock implements mm_service.GroupWriter
type GroupWriterMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddGroup          func(ctx context.Context, group entity.Group) (g1 entity.GroupId, err error)
	funcAddGroupOrigin    string
	inspectFuncAddGroup   func(ctx context.Context, group entity.Group)
	afterAddGroupCounter  uint64
	beforeAddGroupCounter uint64
	AddGroupMock          mGroupWriterMockAddGroup

	funcDeleteGroup          func(ctx context.Context, groupId entity.GroupId) (err error)
	funcDeleteGroupOrigin    string
	inspectFuncDeleteGroup   func(ctx context.Context, groupId entity.GroupId)
	afterDeleteGroupCounter  uint64
	beforeDeleteGroupCounter uint64
	DeleteGroupMock          mGroupWriterMockDeleteGroup

	funcUpdateGroup          func(ctx context.Context, group entity.Group) (err error)
	funcUpdateGroupOrigin    string
	inspectFuncUpdateGroup   func(ctx context.Context, group entity.Group)
	afterUpdateGroupCounter  uint64
	beforeUpdateGroupCounter uint64
	UpdateGroupMock          mGroupWriterMockUpdateGroup
}

// NewGroupWriterMock returns a mock for mm_service.GroupWriter
func NewGroupWriterMock(t minimock.Tester) *GroupWriterMock {
	m := &GroupWriterMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddGroupMock = mGroupWriterMockAddGroup{mock: m}
	m.AddGroupMock.callArgs = []*GroupWriterMockAddGroupParams{}

	m.DeleteGroupMock = mGroupWriterMockDeleteGroup{mock: m}
	m.DeleteGroupMock.callArgs = []*GroupWriterMockDeleteGroupParams{}

	m.UpdateGroupMock = mGroupWriterMockUpdateGroup{mock: m}
	m.UpdateGroupMock.callArgs = []*GroupWriterMockUpdateGroupParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mGroupWriterMockAddGroup struct {
	optional           bool
	mock               *GroupWriterMock
	defaultExpectation *GroupWriterMockAddGroupExpectation
	expectations       []*GroupWriterMockAddGroupExpectation

	callArgs []*GroupWriterMockAddGroupParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupWriterMockAddGroupExpectation specifies expectation struct of the GroupWriter.AddGroup
type GroupWriterMockAddGroupExpectation struct {
	mock               *GroupWriterMock
	params             *GroupWriterMockAddGroupParams
	paramPtrs          *GroupWriterMockAddGroupParamPtrs
	expectationOrigins GroupWriterMockAddGroupExpectationOrigins
	results            *GroupWriterMockAddGroupResults
	returnOrigin       string
	Counter            uint64
}

// GroupWriterMockAddGroupParams contains parameters of the GroupWriter.AddGroup
type GroupWriterMockAddGroupParams struct {
	ctx   context.Context
	group entity.Group
}

// GroupWriterMockAddGroupParamPtrs contains pointers to parameters of the GroupWriter.AddGroup
type GroupWriterMockAddGroupParamPtrs struct {
	ctx   *context.Context
	group *entity.Group
}

// GroupWriterMockAddGroupResults contains results of the GroupWriter.AddGroup
type GroupWriterMockAddGroupResults struct {
	g1  entity.GroupId
	err error
}

// GroupWriterMockAddGroupOrigins contains origins of expectations of the GroupWriter.AddGroup
type GroupWriterMockAddGroupExpectationOrigins struct {
	origin      string
	originCtx   string
	originGroup string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddGroup *mGroupWriterMockAddGroup) Optional() *mGroupWriterMockAddGroup {
	mmAddGroup.optional = true
	return mmAddGroup
}

// Expect sets up expected params for GroupWriter.AddGroup
func (mmAddGroup *mGroupWriterMockAddGroup) Expect(ctx context.Context, group entity.Group) *mGroupWriterMockAddGroup {
	if mmAddGroup.mock.funcAddGroup != nil {
		mmAddGroup.mock.t.Fatalf("GroupWriterMock.AddGroup mock is already set by Set")
	}

	if mmAddGroup.defaultExpectation == nil {
		mmAddGroup.defaultExpectation = &GroupWriterMockAddGroupExpectation{}
	}

	if mmAddGroup.defaultExpectation.paramPtrs != nil {
		mmAddGroup.mock.t.Fatalf("GroupWriterMock.AddGroup mock is already set by ExpectParams functions")
	}

	mmAddGroup.defaultExpectation.params = &GroupWriterMockAddGroupParams{ctx, group}
	mmAddGroup.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddGroup.expectations {
		if minimock.Equal(e.params, mmAddGroup.defaultExpectation.params) {
			mmAddGroup.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddGroup.defaultExpectation.params)
		}
	}

	return mmAddGroup
}

// ExpectCtxParam1 sets up expected param ctx for GroupWriter.AddGroup
func (mmAddGroup *mGroupWriterMockAddGroup) ExpectCtxParam1(ctx context.Context) *mGroupWriterMockAddGroup {
	if mmAddGroup.mock.funcAddGroup != nil {
		mmAddGroup.mock.t.Fatalf("GroupWriterMock.AddGroup mock is already set by Set")
	}

	if mmAddGroup.defaultExpectation == nil {
		mmAddGroup.defaultExpectation = &GroupWriterMockAddGroupExpectation{}
	}

	if mmAddGroup.defaultExpectation.params != nil {
		mmAddGroup.mock.t.Fatalf("GroupWriterMock.AddGroup mock is already set by Expect")
	}

	if mmAddGroup.defaultExpectation.paramPtrs == nil {
		mmAddGroup.defaultExpectation.paramPtrs = &GroupWriterMockAddGroupParamPtrs{}
	}
	mmAddGroup.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddGroup.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddGroup
}

// ExpectGroupParam2 sets up expected param group for GroupWriter.AddGroup
func (mmAddGroup *mGroupWriterMockAddGroup) ExpectGroupParam2(group entity.Group) *mGroupWriterMockAddGroup {
	if mmAddGroup.mock.funcAddGroup != nil {
		mmAddGroup.mock.t.Fatalf("GroupWriterMock.AddGroup mock is already set by Set")
	}

	if mmAddGroup.defaultExpectation == nil {
		mmAddGroup.defaultExpectation = &GroupWriterMockAddGroupExpectation{}
	}

	if mmAddGroup.defaultExpectation.params != nil {
		mmAddGroup.mock.t.Fatalf("GroupWriterMock.AddGroup mock is already set by Expect")
	}

	if mmAddGroup.defaultExpectation.paramPtrs == nil {
		mmAddGroup.defaultExpectation.paramPtrs = &GroupWriterMockAddGroupParamPtrs{}
	}
	mmAddGroup.defaultExpectation.paramPtrs.group = &group
	mmAddGroup.defaultExpectation.expectationOrigins.originGroup = minimock.CallerInfo(1)

	return mmAddGroup
}

// Inspect accepts an inspector function that has same arguments as the GroupWriter.AddGroup
func (mmAddGroup *mGroupWriterMockAddGroup) Inspect(f func(ctx context.Context, group entity.Group)) *mGroupWriterMockAddGroup {
	if mmAddGroup.mock.inspectFuncAddGroup != nil {
		mmAddGroup.mock.t.Fatalf("Inspect function is already set for GroupWriterMock.AddGroup")
	}

	mmAddGroup.mock.inspectFuncAddGroup = f

	return mmAddGroup
}

// Return sets up results that will be returned by GroupWriter.AddGroup
func (mmAddGroup *mGroupWriterMockAddGroup) Return(g1 entity.GroupId, err error) *GroupWriterMock {
	if mmAddGroup.mock.funcAddGroup != nil {
		mmAddGroup.mock.t.Fatalf("GroupWriterMock.AddGroup mock is already set by Set")
	}

	if mmAddGroup.defaultExpectation == nil {
		mmAddGroup.defaultExpectation = &GroupWriterMockAddGroupExpectation{mock: mmAddGroup.mock}
	}
	mmAddGroup.defaultExpectation.results = &GroupWriterMockAddGroupResults{g1, err}
	mmAddGroup.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddGroup.mock
}

// Set uses given function f to mock the GroupWriter.AddGroup method
func (mmAddGroup *mGroupWriterMockAddGroup) Set(f func(ctx context.Context, group entity.Group) (g1 entity.GroupId, err error)) *GroupWriterMock {
	if mmAddGroup.defaultExpectation != nil {
		mmAddGroup.mock.t.Fatalf("Default expectation is already set for the GroupWriter.AddGroup method")
	}

	if len(mmAddGroup.expectations) > 0 {
		mmAddGroup.mock.t.Fatalf("Some expectations are already set for the GroupWriter.AddGroup method")
	}

	mmAddGroup.mock.funcAddGroup = f
	mmAddGroup.mock.funcAddGroupOrigin = minimock.CallerInfo(1)
	return mmAddGroup.mock
}

// When sets expectation for the GroupWriter.AddGroup which will trigger the result defined by the following
// Then helper
func (mmAddGroup *mGroupWriterMockAddGroup) When(ctx context.Context, group entity.Group) *GroupWriterMockAddGroupExpectation {
	if mmAddGroup.mock.funcAddGroup != nil {
		mmAddGroup.mock.t.Fatalf("GroupWriterMock.AddGroup mock is already set by Set")
	}

	expectation := &GroupWriterMockAddGroupExpectation{
		mock:               mmAddGroup.mock,
		params:             &GroupWriterMockAddGroupParams{ctx, group},
		expectationOrigins: GroupWriterMockAddGroupExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddGroup.expectations = append(mmAddGroup.expectations, expectation)
	return expectation
}

// Then sets up GroupWriter.AddGroup return parameters for the expectation previously defined by the When method
func (e *GroupWriterMockAddGroupExpectation) Then(g1 entity.GroupId, err error) *GroupWriterMock {
	e.results = &GroupWriterMockAddGroupResults{g1, err}
	return e.mock
}

// Times sets number of times GroupWriter.AddGroup should be invoked
func (mmAddGroup *mGroupWriterMockAddGroup) Times(n uint64) *mGroupWriterMockAddGroup {
	if n == 0 {
		mmAddGroup.mock.t.Fatalf("Times of GroupWriterMock.AddGroup mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddGroup.expectedInvocations, n)
	mmAddGroup.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddGroup
}

func (mmAddGroup *mGroupWriterMockAddGroup) invocationsDone() bool {
	if len(mmAddGroup.expectations) == 0 && mmAddGroup.defaultExpectation == nil && mmAddGroup.mock.funcAddGroup == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddGroup.mock.afterAddGroupCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddGroup.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddGroup implements mm_service.GroupWriter
func (mmAddGroup *GroupWriterMock) AddGroup(ctx context.Context, group entity.Group) (g1 entity.GroupId, err error) {
	mm_atomic.AddUint64(&mmAddGroup.beforeAddGroupCounter, 1)
	defer mm_atomic.AddUint64(&mmAddGroup.afterAddGroupCounter, 1)

	mmAddGroup.t.Helper()

	if mmAddGroup.inspectFuncAddGroup != nil {
		mmAddGroup.inspectFuncAddGroup(ctx, group)
	}

	mm_params := GroupWriterMockAddGroupParams{ctx, group}

	// Record call args
	mmAddGroup.AddGroupMock.mutex.Lock()
	mmAddGroup.AddGroupMock.callArgs = append(mmAddGroup.AddGroupMock.callArgs, &mm_params)
	mmAddGroup.AddGroupMock.mutex.Unlock()

	for _, e := range mmAddGroup.AddGroupMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.g1, e.results.err
		}
	}

	if mmAddGroup.AddGroupMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddGroup.AddGroupMock.defaultExpectation.Counter, 1)
		mm_want := mmAddGroup.AddGroupMock.defaultExpectation.params
		mm_want_ptrs := mmAddGroup.AddGroupMock.defaultExpectation.paramPtrs

		mm_got := GroupWriterMockAddGroupParams{ctx, group}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddGroup.t.Errorf("GroupWriterMock.AddGroup got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddGroup.AddGroupMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.group != nil && !minimock.Equal(*mm_want_ptrs.group, mm_got.group) {
				mmAddGroup.t.Errorf("GroupWriterMock.AddGroup got unexpected parameter group, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddGroup.AddGroupMock.defaultExpectation.expectationOrigins.originGroup, *mm_want_ptrs.group, mm_got.group, minimock.Diff(*mm_want_ptrs.group, mm_got.group))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddGroup.t.Errorf("GroupWriterMock.AddGroup got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddGroup.AddGroupMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddGroup.AddGroupMock.defaultExpectation.results
		if mm_results == nil {
			mmAddGroup.t.Fatal("No results are set for the GroupWriterMock.AddGroup")
		}
		return (*mm_results).g1, (*mm_results).err
	}
	if mmAddGroup.funcAddGroup != nil {
		return mmAddGroup.funcAddGroup(ctx, group)
	}
	mmAddGroup.t.Fatalf("Unexpected call to GroupWriterMock.AddGroup. %v %v", ctx, group)
	return
}

// AddGroupAfterCounter returns a count of finished GroupWriterMock.AddGroup invocations
func (mmAddGroup *GroupWriterMock) AddGroupAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddGroup.afterAddGroupCounter)
}

// AddGroupBeforeCounter returns a count of GroupWriterMock.AddGroup invocations
func (mmAddGroup *GroupWriterMock) AddGroupBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddGroup.beforeAddGroupCounter)
}

// Calls returns a list of arguments used in each call to GroupWriterMock.AddGroup.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddGroup *mGroupWriterMockAddGroup) Calls() []*GroupWriterMockAddGroupParams {
	mmAddGroup.mutex.RLock()

	argCopy := make([]*GroupWriterMockAddGroupParams, len(mmAddGroup.callArgs))
	copy(argCopy, mmAddGroup.callArgs)

	mmAddGroup.mutex.RUnlock()

	return argCopy
}

// MinimockAddGroupDone returns true if the count of the AddGroup invocations corresponds
// the number of defined expectations
func (m *GroupWriterMock) MinimockAddGroupDone() bool {
	if m.AddGroupMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddGroupMock.invocationsDone()
}

// MinimockAddGroupInspect logs each unmet expectation
func (m *GroupWriterMock) MinimockAddGroupInspect() {
	for _, e := range m.AddGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupWriterMock.AddGroup at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddGroupCounter := mm_atomic.LoadUint64(&m.afterAddGroupCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddGroupMock.defaultExpectation != nil && afterAddGroupCounter < 1 {
		if m.AddGroupMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupWriterMock.AddGroup at\n%s", m.AddGroupMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupWriterMock.AddGroup at\n%s with params: %#v", m.AddGroupMock.defaultExpectation.expectationOrigins.origin, *m.AddGroupMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddGroup != nil && afterAddGroupCounter < 1 {
		m.t.Errorf("Expected call to GroupWriterMock.AddGroup at\n%s", m.funcAddGroupOrigin)
	}

	if !m.AddGroupMock.invocationsDone() && afterAddGroupCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupWriterMock.AddGroup at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddGroupMock.expectedInvocations), m.AddGroupMock.expectedInvocationsOrigin, afterAddGroupCounter)
	}
}

type mGroupWriterMockDeleteGroup struct {
	optional           bool
	mock               *GroupWriterMock
	defaultExpectation *GroupWriterMockDeleteGroupExpectation
	expectations       []*GroupWriterMockDeleteGroupExpectation

	callArgs []*GroupWriterMockDeleteGroupParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupWriterMockDeleteGroupExpectation specifies expectation struct of the GroupWriter.DeleteGroup
type GroupWriterMockDeleteGroupExpectation struct {
	mock               *GroupWriterMock
	params             *GroupWriterMockDeleteGroupParams
	paramPtrs          *GroupWriterMockDeleteGroupParamPtrs
	expectationOrigins GroupWriterMockDeleteGroupExpectationOrigins
	results            *GroupWriterMockDeleteGroupResults
	returnOrigin       string
	Counter            uint64
}

// GroupWriterMockDeleteGroupParams contains parameters of the GroupWriter.DeleteGroup
type GroupWriterMockDeleteGroupParams struct {
	ctx     context.Context
	groupId entity.GroupId
}

// GroupWriterMockDeleteGroupParamPtrs contains pointers to parameters of the GroupWriter.DeleteGroup
type GroupWriterMockDeleteGroupParamPtrs struct {
	ctx     *context.Context
	groupId *entity.GroupId
}

// GroupWriterMockDeleteGroupResults contains results of the GroupWriter.DeleteGroup
type GroupWriterMockDeleteGroupResults struct {
	err error
}

// GroupWriterMockDeleteGroupOrigins contains origins of expectations of the GroupWriter.DeleteGroup
type GroupWriterMockDeleteGroupExpectationOrigins struct {
	origin        string
	originCtx     string
	originGroupId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteGroup *mGroupWriterMockDeleteGroup) Optional() *mGroupWriterMockDeleteGroup {
	mmDeleteGroup.optional = true
	return mmDeleteGroup
}

// Expect sets up expected params for GroupWriter.DeleteGroup
func (mmDeleteGroup *mGroupWriterMockDeleteGroup) Expect(ctx context.Context, groupId entity.GroupId) *mGroupWriterMockDeleteGroup {
	if mmDeleteGroup.mock.funcDeleteGroup != nil {
		mmDeleteGroup.mock.t.Fatalf("GroupWriterMock.DeleteGroup mock is already set by Set")
	}

	if mmDeleteGroup.defaultExpectation == nil {
		mmDeleteGroup.defaultExpectation = &GroupWriterMockDeleteGroupExpectation{}
	}

	if mmDeleteGroup.defaultExpectation.paramPtrs != nil {
		mmDeleteGroup.mock.t.Fatalf("GroupWriterMock.DeleteGroup mock is already set by ExpectParams functions")
	}

	mmDeleteGroup.defaultExpectation.params = &GroupWriterMockDeleteGroupParams{ctx, groupId}
	mmDeleteGroup.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteGroup.expectations {
		if minimock.Equal(e.params, mmDeleteGroup.defaultExpectation.params) {
			mmDeleteGroup.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteGroup.defaultExpectation.params)
		}
	}

	return mmDeleteGroup
}

// ExpectCtxParam1 sets up expected param ctx for GroupWriter.DeleteGroup
func (mmDeleteGroup *mGroupWriterMockDeleteGroup) ExpectCtxParam1(ctx context.Context) *mGroupWriterMockDeleteGroup {
	if mmDeleteGroup.mock.funcDeleteGroup != nil {
		mmDeleteGroup.mock.t.Fatalf("GroupWriterMock.DeleteGroup mock is already set by Set")
	}

	if mmDeleteGroup.defaultExpectation == nil {
		mmDeleteGroup.defaultExpectation = &GroupWriterMockDeleteGroupExpectation{}
	}

	if mmDeleteGroup.defaultExpectation.params != nil {
		mmDeleteGroup.mock.t.Fatalf("GroupWriterMock.DeleteGroup mock is already set by Expect")
	}

	if mmDeleteGroup.defaultExpectation.paramPtrs == nil {
		mmDeleteGroup.defaultExpectation.paramPtrs = &GroupWriterMockDeleteGroupParamPtrs{}
	}
	mmDeleteGroup.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteGroup.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteGroup
}

// ExpectGroupIdParam2 sets up expected param groupId for GroupWriter.DeleteGroup
func (mmDeleteGroup *mGroupWriterMockDeleteGroup) ExpectGroupIdParam2(groupId entity.GroupId) *mGroupWriterMockDeleteGroup {
	if mmDeleteGroup.mock.funcDeleteGroup != nil {
		mmDeleteGroup.mock.t.Fatalf("GroupWriterMock.DeleteGroup mock is already set by Set")
	}

	if mmDeleteGroup.defaultExpectation == nil {
		mmDeleteGroup.defaultExpectation = &GroupWriterMockDeleteGroupExpectation{}
	}

	if mmDeleteGroup.defaultExpectation.params != nil {
		mmDeleteGroup.mock.t.Fatalf("GroupWriterMock.DeleteGroup mock is already set by Expect")
	}

	if mmDeleteGroup.defaultExpectation.paramPtrs == nil {
		mmDeleteGroup.defaultExpectation.paramPtrs = &GroupWriterMockDeleteGroupParamPtrs{}
	}
	mmDeleteGroup.defaultExpectation.paramPtrs.groupId = &groupId
	mmDeleteGroup.defaultExpectation.expectationOrigins.originGroupId = minimock.CallerInfo(1)

	return mmDeleteGroup
}

// Inspect accepts an inspector function that has same arguments as the GroupWriter.DeleteGroup
func (mmDeleteGroup *mGroupWriterMockDeleteGroup) Inspect(f func(ctx context.Context, groupId entity.GroupId)) *mGroupWriterMockDeleteGroup {
	if mmDeleteGroup.mock.inspectFuncDeleteGroup != nil {
		mmDeleteGroup.mock.t.Fatalf("Inspect function is already set for GroupWriterMock.DeleteGroup")
	}

	mmDeleteGroup.mock.inspectFuncDeleteGroup = f

	return mmDeleteGroup
}

// Return sets up results that will be returned by GroupWriter.DeleteGroup
func (mmDeleteGroup *mGroupWriterMockDeleteGroup) Return(err error) *GroupWriterMock {
	if mmDeleteGroup.mock.funcDeleteGroup != nil {
		mmDeleteGroup.mock.t.Fatalf("GroupWriterMock.DeleteGroup mock is already set by Set")
	}

	if mmDeleteGroup.defaultExpectation == nil {
		mmDeleteGroup.defaultExpectation = &GroupWriterMockDeleteGroupExpectation{mock: mmDeleteGroup.mock}
	}
	mmDeleteGroup.defaultExpectation.results = &GroupWriterMockDeleteGroupResults{err}
	mmDeleteGroup.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteGroup.mock
}

// Set uses given function f to mock the GroupWriter.DeleteGroup method
func (mmDeleteGroup *mGroupWriterMockDeleteGroup) Set(f func(ctx context.Context, groupId entity.GroupId) (err error)) *GroupWriterMock {
	if mmDeleteGroup.defaultExpectation != nil {
		mmDeleteGroup.mock.t.Fatalf("Default expectation is already set for the GroupWriter.DeleteGroup method")
	}

	if len(mmDeleteGroup.expectations) > 0 {
		mmDeleteGroup.mock.t.Fatalf("Some expectations are already set for the GroupWriter.DeleteGroup method")
	}

	mmDeleteGroup.mock.funcDeleteGroup = f
	mmDeleteGroup.mock.funcDeleteGroupOrigin = minimock.CallerInfo(1)
	return mmDeleteGroup.mock
}

// When sets expectation for the GroupWriter.DeleteGroup which will trigger the result defined by the following
// Then helper
func (mmDeleteGroup *mGroupWriterMockDeleteGroup) When(ctx context.Context, groupId entity.GroupId) *GroupWriterMockDeleteGroupExpectation {
	if mmDeleteGroup.mock.funcDeleteGroup != nil {
		mmDeleteGroup.mock.t.Fatalf("GroupWriterMock.DeleteGroup mock is already set by Set")
	}

	expectation := &GroupWriterMockDeleteGroupExpectation{
		mock:               mmDeleteGroup.mock,
		params:             &GroupWriterMockDeleteGroupParams{ctx, groupId},
		expectationOrigins: GroupWriterMockDeleteGroupExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteGroup.expectations = append(mmDeleteGroup.expectations, expectation)
	return expectation
}

// Then sets up GroupWriter.DeleteGroup return parameters for the expectation previously defined by the When method
func (e *GroupWriterMockDeleteGroupExpectation) Then(err error) *GroupWriterMock {
	e.results = &GroupWriterMockDeleteGroupResults{err}
	return e.mock
}

// Times sets number of times GroupWriter.DeleteGroup should be invoked
func (mmDeleteGroup *mGroupWriterMockDeleteGroup) Times(n uint64) *mGroupWriterMockDeleteGroup {
	if n == 0 {
		mmDeleteGroup.mock.t.Fatalf("Times of GroupWriterMock.DeleteGroup mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteGroup.expectedInvocations, n)
	mmDeleteGroup.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteGroup
}

func (mmDeleteGroup *mGroupWriterMockDeleteGroup) invocationsDone() bool {
	if len(mmDeleteGroup.expectations) == 0 && mmDeleteGroup.defaultExpectation == nil && mmDeleteGroup.mock.funcDeleteGroup == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteGroup.mock.afterDeleteGroupCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteGroup.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteGroup implements mm_service.GroupWriter
func (mmDeleteGroup *GroupWriterMock) DeleteGroup(ctx context.Context, groupId entity.GroupId) (err error) {
	mm_atomic.AddUint64(&mmDeleteGroup.beforeDeleteGroupCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteGroup.afterDeleteGroupCounter, 1)

	mmDeleteGroup.t.Helper()

	if mmDeleteGroup.inspectFuncDeleteGroup != nil {
		mmDeleteGroup.inspectFuncDeleteGroup(ctx, groupId)
	}

	mm_params := GroupWriterMockDeleteGroupParams{ctx, groupId}

	// Record call args
	mmDeleteGroup.DeleteGroupMock.mutex.Lock()
	mmDeleteGroup.DeleteGroupMock.callArgs = append(mmDeleteGroup.DeleteGroupMock.callArgs, &mm_params)
	mmDeleteGroup.DeleteGroupMock.mutex.Unlock()

	for _, e := range mmDeleteGroup.DeleteGroupMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteGroup.DeleteGroupMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteGroup.DeleteGroupMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteGroup.DeleteGroupMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteGroup.DeleteGroupMock.defaultExpectation.paramPtrs

		mm_got := GroupWriterMockDeleteGroupParams{ctx, groupId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteGroup.t.Errorf("GroupWriterMock.DeleteGroup got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteGroup.DeleteGroupMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.groupId != nil && !minimock.Equal(*mm_want_ptrs.groupId, mm_got.groupId) {
				mmDeleteGroup.t.Errorf("GroupWriterMock.DeleteGroup got unexpected parameter groupId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteGroup.DeleteGroupMock.defaultExpectation.expectationOrigins.originGroupId, *mm_want_ptrs.groupId, mm_got.groupId, minimock.Diff(*mm_want_ptrs.groupId, mm_got.groupId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteGroup.t.Errorf("GroupWriterMock.DeleteGroup got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteGroup.DeleteGroupMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteGroup.DeleteGroupMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteGroup.t.Fatal("No results are set for the GroupWriterMock.DeleteGroup")
		}
		return (*mm_results).err
	}
	if mmDeleteGroup.funcDeleteGroup != nil {
		return mmDeleteGroup.funcDeleteGroup(ctx, groupId)
	}
	mmDeleteGroup.t.Fatalf("Unexpected call to GroupWriterMock.DeleteGroup. %v %v", ctx, groupId)
	return
}

// DeleteGroupAfterCounter returns a count of finished GroupWriterMock.DeleteGroup invocations
func (mmDeleteGroup *GroupWriterMock) DeleteGroupAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteGroup.afterDeleteGroupCounter)
}

// DeleteGroupBeforeCounter returns a count of GroupWriterMock.DeleteGroup invocations
func (mmDeleteGroup *GroupWriterMock) DeleteGroupBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteGroup.beforeDeleteGroupCounter)
}

// Calls returns a list of arguments used in each call to GroupWriterMock.DeleteGroup.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteGroup *mGroupWriterMockDeleteGroup) Calls() []*GroupWriterMockDeleteGroupParams {
	mmDeleteGroup.mutex.RLock()

	argCopy := make([]*GroupWriterMockDeleteGroupParams, len(mmDeleteGroup.callArgs))
	copy(argCopy, mmDeleteGroup.callArgs)

	mmDeleteGroup.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteGroupDone returns true if the count of the DeleteGroup invocations corresponds
// the number of defined expectations
func (m *GroupWriterMock) MinimockDeleteGroupDone() bool {
	if m.DeleteGroupMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteGroupMock.invocationsDone()
}

// MinimockDeleteGroupInspect logs each unmet expectation
func (m *GroupWriterMock) MinimockDeleteGroupInspect() {
	for _, e := range m.DeleteGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupWriterMock.DeleteGroup at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteGroupCounter := mm_atomic.LoadUint64(&m.afterDeleteGroupCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteGroupMock.defaultExpectation != nil && afterDeleteGroupCounter < 1 {
		if m.DeleteGroupMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupWriterMock.DeleteGroup at\n%s", m.DeleteGroupMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupWriterMock.DeleteGroup at\n%s with params: %#v", m.DeleteGroupMock.defaultExpectation.expectationOrigins.origin, *m.DeleteGroupMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteGroup != nil && afterDeleteGroupCounter < 1 {
		m.t.Errorf("Expected call to GroupWriterMock.DeleteGroup at\n%s", m.funcDeleteGroupOrigin)
	}

	if !m.DeleteGroupMock.invocationsDone() && afterDeleteGroupCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupWriterMock.DeleteGroup at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteGroupMock.expectedInvocations), m.DeleteGroupMock.expectedInvocationsOrigin, afterDeleteGroupCounter)
	}
}

type mGroupWriterMockUpdateGroup struct {
	optional           bool
	mock               *GroupWriterMock
	defaultExpectation *GroupWriterMockUpdateGroupExpectation
	expectations       []*GroupWriterMockUpdateGroupExpectation

	callArgs []*GroupWriterMockUpdateGroupParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupWriterMockUpdateGroupExpectation specifies expectation struct of the GroupWriter.UpdateGroup
type GroupWriterMockUpdateGroupExpectation struct {
	mock               *GroupWriterMock
	params             *GroupWriterMockUpdateGroupParams
	paramPtrs          *GroupWriterMockUpdateGroupParamPtrs
	expectationOrigins GroupWriterMockUpdateGroupExpectationOrigins
	results            *GroupWriterMockUpdateGroupResults
	returnOrigin       string
	Counter            uint64
}

// GroupWriterMockUpdateGroupParams contains parameters of the GroupWriter.UpdateGroup
type GroupWriterMockUpdateGroupParams struct {
	ctx   context.Context
	group entity.Group
}

// GroupWriterMockUpdateGroupParamPtrs contains pointers to parameters of the GroupWriter.UpdateGroup
type GroupWriterMockUpdateGroupParamPtrs struct {
	ctx   *context.Context
	group *entity.Group
}

// GroupWriterMockUpdateGroupResults contains results of the GroupWriter.UpdateGroup
type GroupWriterMockUpdateGroupResults struct {
	err error
}

// GroupWriterMockUpdateGroupOrigins contains origins of expectations of the GroupWriter.UpdateGroup
type GroupWriterMockUpdateGroupExpectationOrigins struct {
	origin      string
	originCtx   string
	originGroup string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateGroup *mGroupWriterMockUpdateGroup) Optional() *mGroupWriterMockUpdateGroup {
	mmUpdateGroup.optional = true
	return mmUpdateGroup
}

// Expect sets up expected params for GroupWriter.UpdateGroup
func (mmUpdateGroup *mGroupWriterMockUpdateGroup) Expect(ctx context.Context, group entity.Group) *mGroupWriterMockUpdateGroup {
	if mmUpdateGroup.mock.funcUpdateGroup != nil {
		mmUpdateGroup.mock.t.Fatalf("GroupWriterMock.UpdateGroup mock is already set by Set")
	}

	if mmUpdateGroup.defaultExpectation == nil {
		mmUpdateGroup.defaultExpectation = &GroupWriterMockUpdateGroupExpectation{}
	}

	if mmUpdateGroup.defaultExpectation.paramPtrs != nil {
		mmUpdateGroup.mock.t.Fatalf("GroupWriterMock.UpdateGroup mock is already set by ExpectParams functions")
	}

	mmUpdateGroup.defaultExpectation.params = &GroupWriterMockUpdateGroupParams{ctx, group}
	mmUpdateGroup.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateGroup.expectations {
		if minimock.Equal(e.params, mmUpdateGroup.defaultExpectation.params) {
			mmUpdateGroup.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateGroup.defaultExpectation.params)
		}
	}

	return mmUpdateGroup
}

// ExpectCtxParam1 sets up expected param ctx for GroupWriter.UpdateGroup
func (mmUpdateGroup *mGroupWriterMockUpdateGroup) ExpectCtxParam1(ctx context.Context) *mGroupWriterMockUpdateGroup {
	if mmUpdateGroup.mock.funcUpdateGroup != nil {
		mmUpdateGroup.mock.t.Fatalf("GroupWriterMock.UpdateGroup mock is already set by Set")
	}

	if mmUpdateGroup.defaultExpectation == nil {
		mmUpdateGroup.defaultExpectation = &GroupWriterMockUpdateGroupExpectation{}
	}

	if mmUpdateGroup.defaultExpectation.params != nil {
		mmUpdateGroup.mock.t.Fatalf("GroupWriterMock.UpdateGroup mock is already set by Expect")
	}

	if mmUpdateGroup.defaultExpectation.paramPtrs == nil {
		mmUpdateGroup.defaultExpectation.paramPtrs = &GroupWriterMockUpdateGroupParamPtrs{}
	}
	mmUpdateGroup.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateGroup.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateGroup
}

// ExpectGroupParam2 sets up expected param group for GroupWriter.UpdateGroup
func (mmUpdateGroup *mGroupWriterMockUpdateGroup) ExpectGroupParam2(group entity.Group) *mGroupWriterMockUpdateGroup {
	if mmUpdateGroup.mock.funcUpdateGroup != nil {
		mmUpdateGroup.mock.t.Fatalf("GroupWriterMock.UpdateGroup mock is already set by Set")
	}

	if mmUpdateGroup.defaultExpectation == nil {
		mmUpdateGroup.defaultExpectation = &GroupWriterMockUpdateGroupExpectation{}
	}

	if mmUpdateGroup.defaultExpectation.params != nil {
		mmUpdateGroup.mock.t.Fatalf("GroupWriterMock.UpdateGroup mock is already set by Expect")
	}

	if mmUpdateGroup.defaultExpectation.paramPtrs == nil {
		mmUpdateGroup.defaultExpectation.paramPtrs = &GroupWriterMockUpdateGroupParamPtrs{}
	}
	mmUpdateGroup.defaultExpectation.paramPtrs.group = &group
	mmUpdateGroup.defaultExpectation.expectationOrigins.originGroup = minimock.CallerInfo(1)

	return mmUpdateGroup
}

// Inspect accepts an inspector function that has same arguments as the GroupWriter.UpdateGroup
func (mmUpdateGroup *mGroupWriterMockUpdateGroup) Inspect(f func(ctx context.Context, group entity.Group)) *mGroupWriterMockUpdateGroup {
	if mmUpdateGroup.mock.inspectFuncUpdateGroup != nil {
		mmUpdateGroup.mock.t.Fatalf("Inspect function is already set for GroupWriterMock.UpdateGroup")
	}

	mmUpdateGroup.mock.inspectFuncUpdateGroup = f

	return mmUpdateGroup
}

// Return sets up results that will be returned by GroupWriter.UpdateGroup
func (mmUpdateGroup *mGroupWriterMockUpdateGroup) Return(err error) *GroupWriterMock {
	if mmUpdateGroup.mock.funcUpdateGroup != nil {
		mmUpdateGroup.mock.t.Fatalf("GroupWriterMock.UpdateGroup mock is already set by Set")
	}

	if mmUpdateGroup.defaultExpectation == nil {
		mmUpdateGroup.defaultExpectation = &GroupWriterMockUpdateGroupExpectation{mock: mmUpdateGroup.mock}
	}
	mmUpdateGroup.defaultExpectation.results = &GroupWriterMockUpdateGroupResults{err}
	mmUpdateGroup.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateGroup.mock
}

// Set uses given function f to mock the GroupWriter.UpdateGroup method
func (mmUpdateGroup *mGroupWriterMockUpdateGroup) Set(f func(ctx context.Context, group entity.Group) (err error)) *GroupWriterMock {
	if mmUpdateGroup.defaultExpectation != nil {
		mmUpdateGroup.mock.t.Fatalf("Default expectation is already set for the GroupWriter.UpdateGroup method")
	}

	if len(mmUpdateGroup.expectations) > 0 {
		mmUpdateGroup.mock.t.Fatalf("Some expectations are already set for the GroupWriter.UpdateGroup method")
	}

	mmUpdateGroup.mock.funcUpdateGroup = f
	mmUpdateGroup.mock.funcUpdateGroupOrigin = minimock.CallerInfo(1)
	return mmUpdateGroup.mock
}

// When sets expectation for the GroupWriter.UpdateGroup which will trigger the result defined by the following
// Then helper
func (mmUpdateGroup *mGroupWriterMockUpdateGroup) When(ctx context.Context, group entity.Group) *GroupWriterMockUpdateGroupExpectation {
	if mmUpdateGroup.mock.funcUpdateGroup != nil {
		mmUpdateGroup.mock.t.Fatalf("GroupWriterMock.UpdateGroup mock is already set by Set")
	}

	expectation := &GroupWriterMockUpdateGroupExpectation{
		mock:               mmUpdateGroup.mock,
		params:             &GroupWriterMockUpdateGroupParams{ctx, group},
		expectationOrigins: GroupWriterMockUpdateGroupExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateGroup.expectations = append(mmUpdateGroup.expectations, expectation)
	return expectation
}

// Then sets up GroupWriter.UpdateGroup return parameters for the expectation previously defined by the When method
func (e *GroupWriterMockUpdateGroupExpectation) Then(err error) *GroupWriterMock {
	e.results = &GroupWriterMockUpdateGroupResults{err}
	return e.mock
}

// Times sets number of times GroupWriter.UpdateGroup should be invoked
func (mmUpdateGroup *mGroupWriterMockUpdateGroup) Times(n uint64) *mGroupWriterMockUpdateGroup {
	if n == 0 {
		mmUpdateGroup.mock.t.Fatalf("Times of GroupWriterMock.UpdateGroup mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateGroup.expectedInvocations, n)
	mmUpdateGroup.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateGroup
}

func (mmUpdateGroup *mGroupWriterMockUpdateGroup) invocationsDone() bool {
	if len(mmUpdateGroup.expectations) == 0 && mmUpdateGroup.defaultExpectation == nil && mmUpdateGroup.mock.funcUpdateGroup == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateGroup.mock.afterUpdateGroupCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateGroup.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateGroup implements mm_service.GroupWriter
func (mmUpdateGroup *GroupWriterMock) UpdateGroup(ctx context.Context, group entity.Group) (err error) {
	mm_atomic.AddUint64(&mmUpdateGroup.beforeUpdateGroupCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateGroup.afterUpdateGroupCounter, 1)

	mmUpdateGroup.t.Helper()

	if mmUpdateGroup.inspectFuncUpdateGroup != nil {
		mmUpdateGroup.inspectFuncUpdateGroup(ctx, group)
	}

	mm_params := GroupWriterMockUpdateGroupParams{ctx, group}

	// Record call args
	mmUpdateGroup.UpdateGroupMock.mutex.Lock()
	mmUpdateGroup.UpdateGroupMock.callArgs = append(mmUpdateGroup.UpdateGroupMock.callArgs, &mm_params)
	mmUpdateGroup.UpdateGroupMock.mutex.Unlock()

	for _, e := range mmUpdateGroup.UpdateGroupMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateGroup.UpdateGroupMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateGroup.UpdateGroupMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateGroup.UpdateGroupMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateGroup.UpdateGroupMock.defaultExpectation.paramPtrs

		mm_got := GroupWriterMockUpdateGroupParams{ctx, group}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateGroup.t.Errorf("GroupWriterMock.UpdateGroup got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateGroup.UpdateGroupMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.group != nil && !minimock.Equal(*mm_want_ptrs.group, mm_got.group) {
				mmUpdateGroup.t.Errorf("GroupWriterMock.UpdateGroup got unexpected parameter group, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateGroup.UpdateGroupMock.defaultExpectation.expectationOrigins.originGroup, *mm_want_ptrs.group, mm_got.group, minimock.Diff(*mm_want_ptrs.group, mm_got.group))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateGroup.t.Errorf("GroupWriterMock.UpdateGroup got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateGroup.UpdateGroupMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateGroup.UpdateGroupMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateGroup.t.Fatal("No results are set for the GroupWriterMock.UpdateGroup")
		}
		return (*mm_results).err
	}
	if mmUpdateGroup.funcUpdateGroup != nil {
		return mmUpdateGroup.funcUpdateGroup(ctx, group)
	}
	mmUpdateGroup.t.Fatalf("Unexpected call to GroupWriterMock.UpdateGroup. %v %v", ctx, group)
	return
}

// UpdateGroupAfterCounter returns a count of finished GroupWriterMock.UpdateGroup invocations
func (mmUpdateGroup *GroupWriterMock) UpdateGroupAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateGroup.afterUpdateGroupCounter)
}

// UpdateGroupBeforeCounter returns a count of GroupWriterMock.UpdateGroup invocations
func (mmUpdateGroup *GroupWriterMock) UpdateGroupBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateGroup.beforeUpdateGroupCounter)
}

// Calls returns a list of arguments used in each call to GroupWriterMock.UpdateGroup.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateGroup *mGroupWriterMockUpdateGroup) Calls() []*GroupWriterMockUpdateGroupParams {
	mmUpdateGroup.mutex.RLock()

	argCopy := make([]*GroupWriterMockUpdateGroupParams, len(mmUpdateGroup.callArgs))
	copy(argCopy, mmUpdateGroup.callArgs)

	mmUpdateGroup.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateGroupDone returns true if the count of the UpdateGroup invocations corresponds
// the number of defined expectations
func (m *GroupWriterMock) MinimockUpdateGroupDone() bool {
	if m.UpdateGroupMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateGroupMock.invocationsDone()
}

// MinimockUpdateGroupInspect logs each unmet expectation
func (m *GroupWriterMock) MinimockUpdateGroupInspect() {
	for _, e := range m.UpdateGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupWriterMock.UpdateGroup at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateGroupCounter := mm_atomic.LoadUint64(&m.afterUpdateGroupCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateGroupMock.defaultExpectation != nil && afterUpdateGroupCounter < 1 {
		if m.UpdateGroupMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupWriterMock.UpdateGroup at\n%s", m.UpdateGroupMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupWriterMock.UpdateGroup at\n%s with params: %#v", m.UpdateGroupMock.defaultExpectation.expectationOrigins.origin, *m.UpdateGroupMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateGroup != nil && afterUpdateGroupCounter < 1 {
		m.t.Errorf("Expected call to GroupWriterMock.UpdateGroup at\n%s", m.funcUpdateGroupOrigin)
	}

	if !m.UpdateGroupMock.invocationsDone() && afterUpdateGroupCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupWriterMock.UpdateGroup at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateGroupMock.expectedInvocations), m.UpdateGroupMock.expectedInvocationsOrigin, afterUpdateGroupCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *GroupWriterMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddGroupInspect()

			m.MinimockDeleteGroupInspect()

			m.MinimockUpdateGroupInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *GroupWriterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *GroupWriterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddGroupDone() &&
		m.MinimockDeleteGroupDone() &&
		m.MinimockUpdateGroupDone()
}
