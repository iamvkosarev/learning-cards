// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/iamvkosarev/learning-cards/internal/service.GroupAccessProvider -o group_access_provider_mock.go -n GroupAccessProvider -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/iamvkosarev/learning-cards/internal/domain/entity"
)

// GroupAccessProvider implements mm_service.GroupAccessProvider
type GroupAccessProvider struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcHasReadGroupAccess          func(ctx context.Context, groupId entity.GroupId) (b1 bool, err error)
	funcHasReadGroupAccessOrigin    string
	inspectFuncHasReadGroupAccess   func(ctx context.Context, groupId entity.GroupId)
	afterHasReadGroupAccessCounter  uint64
	beforeHasReadGroupAccessCounter uint64
	HasReadGroupAccessMock          mGroupAccessProviderHasReadGroupAccess

	funcHasWriteGroupAccess          func(ctx context.Context, groupId entity.GroupId) (b1 bool, err error)
	funcHasWriteGroupAccessOrigin    string
	inspectFuncHasWriteGroupAccess   func(ctx context.Context, groupId entity.GroupId)
	afterHasWriteGroupAccessCounter  uint64
	beforeHasWriteGroupAccessCounter uint64
	HasWriteGroupAccessMock          mGroupAccessProviderHasWriteGroupAccess
}

// NewGroupAccessProvider returns a mock for mm_service.GroupAccessProvider
func NewGroupAccessProvider(t minimock.Tester) *GroupAccessProvider {
	m := &GroupAccessProvider{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.HasReadGroupAccessMock = mGroupAccessProviderHasReadGroupAccess{mock: m}
	m.HasReadGroupAccessMock.callArgs = []*GroupAccessProviderHasReadGroupAccessParams{}

	m.HasWriteGroupAccessMock = mGroupAccessProviderHasWriteGroupAccess{mock: m}
	m.HasWriteGroupAccessMock.callArgs = []*GroupAccessProviderHasWriteGroupAccessParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mGroupAccessProviderHasReadGroupAccess struct {
	optional           bool
	mock               *GroupAccessProvider
	defaultExpectation *GroupAccessProviderHasReadGroupAccessExpectation
	expectations       []*GroupAccessProviderHasReadGroupAccessExpectation

	callArgs []*GroupAccessProviderHasReadGroupAccessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupAccessProviderHasReadGroupAccessExpectation specifies expectation struct of the GroupAccessProvider.HasReadGroupAccess
type GroupAccessProviderHasReadGroupAccessExpectation struct {
	mock               *GroupAccessProvider
	params             *GroupAccessProviderHasReadGroupAccessParams
	paramPtrs          *GroupAccessProviderHasReadGroupAccessParamPtrs
	expectationOrigins GroupAccessProviderHasReadGroupAccessExpectationOrigins
	results            *GroupAccessProviderHasReadGroupAccessResults
	returnOrigin       string
	Counter            uint64
}

// GroupAccessProviderHasReadGroupAccessParams contains parameters of the GroupAccessProvider.HasReadGroupAccess
type GroupAccessProviderHasReadGroupAccessParams struct {
	ctx     context.Context
	groupId entity.GroupId
}

// GroupAccessProviderHasReadGroupAccessParamPtrs contains pointers to parameters of the GroupAccessProvider.HasReadGroupAccess
type GroupAccessProviderHasReadGroupAccessParamPtrs struct {
	ctx     *context.Context
	groupId *entity.GroupId
}

// GroupAccessProviderHasReadGroupAccessResults contains results of the GroupAccessProvider.HasReadGroupAccess
type GroupAccessProviderHasReadGroupAccessResults struct {
	b1  bool
	err error
}

// GroupAccessProviderHasReadGroupAccessOrigins contains origins of expectations of the GroupAccessProvider.HasReadGroupAccess
type GroupAccessProviderHasReadGroupAccessExpectationOrigins struct {
	origin        string
	originCtx     string
	originGroupId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHasReadGroupAccess *mGroupAccessProviderHasReadGroupAccess) Optional() *mGroupAccessProviderHasReadGroupAccess {
	mmHasReadGroupAccess.optional = true
	return mmHasReadGroupAccess
}

// Expect sets up expected params for GroupAccessProvider.HasReadGroupAccess
func (mmHasReadGroupAccess *mGroupAccessProviderHasReadGroupAccess) Expect(ctx context.Context, groupId entity.GroupId) *mGroupAccessProviderHasReadGroupAccess {
	if mmHasReadGroupAccess.mock.funcHasReadGroupAccess != nil {
		mmHasReadGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckReadGroupAccess mock is already set by Set")
	}

	if mmHasReadGroupAccess.defaultExpectation == nil {
		mmHasReadGroupAccess.defaultExpectation = &GroupAccessProviderHasReadGroupAccessExpectation{}
	}

	if mmHasReadGroupAccess.defaultExpectation.paramPtrs != nil {
		mmHasReadGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckReadGroupAccess mock is already set by ExpectParams functions")
	}

	mmHasReadGroupAccess.defaultExpectation.params = &GroupAccessProviderHasReadGroupAccessParams{ctx, groupId}
	mmHasReadGroupAccess.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHasReadGroupAccess.expectations {
		if minimock.Equal(e.params, mmHasReadGroupAccess.defaultExpectation.params) {
			mmHasReadGroupAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHasReadGroupAccess.defaultExpectation.params)
		}
	}

	return mmHasReadGroupAccess
}

// ExpectCtxParam1 sets up expected param ctx for GroupAccessProvider.HasReadGroupAccess
func (mmHasReadGroupAccess *mGroupAccessProviderHasReadGroupAccess) ExpectCtxParam1(ctx context.Context) *mGroupAccessProviderHasReadGroupAccess {
	if mmHasReadGroupAccess.mock.funcHasReadGroupAccess != nil {
		mmHasReadGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckReadGroupAccess mock is already set by Set")
	}

	if mmHasReadGroupAccess.defaultExpectation == nil {
		mmHasReadGroupAccess.defaultExpectation = &GroupAccessProviderHasReadGroupAccessExpectation{}
	}

	if mmHasReadGroupAccess.defaultExpectation.params != nil {
		mmHasReadGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckReadGroupAccess mock is already set by Expect")
	}

	if mmHasReadGroupAccess.defaultExpectation.paramPtrs == nil {
		mmHasReadGroupAccess.defaultExpectation.paramPtrs = &GroupAccessProviderHasReadGroupAccessParamPtrs{}
	}
	mmHasReadGroupAccess.defaultExpectation.paramPtrs.ctx = &ctx
	mmHasReadGroupAccess.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHasReadGroupAccess
}

// ExpectGroupIdParam2 sets up expected param groupId for GroupAccessProvider.HasReadGroupAccess
func (mmHasReadGroupAccess *mGroupAccessProviderHasReadGroupAccess) ExpectGroupIdParam2(groupId entity.GroupId) *mGroupAccessProviderHasReadGroupAccess {
	if mmHasReadGroupAccess.mock.funcHasReadGroupAccess != nil {
		mmHasReadGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckReadGroupAccess mock is already set by Set")
	}

	if mmHasReadGroupAccess.defaultExpectation == nil {
		mmHasReadGroupAccess.defaultExpectation = &GroupAccessProviderHasReadGroupAccessExpectation{}
	}

	if mmHasReadGroupAccess.defaultExpectation.params != nil {
		mmHasReadGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckReadGroupAccess mock is already set by Expect")
	}

	if mmHasReadGroupAccess.defaultExpectation.paramPtrs == nil {
		mmHasReadGroupAccess.defaultExpectation.paramPtrs = &GroupAccessProviderHasReadGroupAccessParamPtrs{}
	}
	mmHasReadGroupAccess.defaultExpectation.paramPtrs.groupId = &groupId
	mmHasReadGroupAccess.defaultExpectation.expectationOrigins.originGroupId = minimock.CallerInfo(1)

	return mmHasReadGroupAccess
}

// Inspect accepts an inspector function that has same arguments as the GroupAccessProvider.HasReadGroupAccess
func (mmHasReadGroupAccess *mGroupAccessProviderHasReadGroupAccess) Inspect(f func(ctx context.Context, groupId entity.GroupId)) *mGroupAccessProviderHasReadGroupAccess {
	if mmHasReadGroupAccess.mock.inspectFuncHasReadGroupAccess != nil {
		mmHasReadGroupAccess.mock.t.Fatalf("Inspect function is already set for GroupAccessProvider.CheckReadGroupAccess")
	}

	mmHasReadGroupAccess.mock.inspectFuncHasReadGroupAccess = f

	return mmHasReadGroupAccess
}

// Return sets up results that will be returned by GroupAccessProvider.HasReadGroupAccess
func (mmHasReadGroupAccess *mGroupAccessProviderHasReadGroupAccess) Return(b1 bool, err error) *GroupAccessProvider {
	if mmHasReadGroupAccess.mock.funcHasReadGroupAccess != nil {
		mmHasReadGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckReadGroupAccess mock is already set by Set")
	}

	if mmHasReadGroupAccess.defaultExpectation == nil {
		mmHasReadGroupAccess.defaultExpectation = &GroupAccessProviderHasReadGroupAccessExpectation{mock: mmHasReadGroupAccess.mock}
	}
	mmHasReadGroupAccess.defaultExpectation.results = &GroupAccessProviderHasReadGroupAccessResults{b1, err}
	mmHasReadGroupAccess.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHasReadGroupAccess.mock
}

// Set uses given function f to mock the GroupAccessProvider.HasReadGroupAccess method
func (mmHasReadGroupAccess *mGroupAccessProviderHasReadGroupAccess) Set(f func(ctx context.Context, groupId entity.GroupId) (b1 bool, err error)) *GroupAccessProvider {
	if mmHasReadGroupAccess.defaultExpectation != nil {
		mmHasReadGroupAccess.mock.t.Fatalf("Default expectation is already set for the GroupAccessProvider.CheckReadGroupAccess method")
	}

	if len(mmHasReadGroupAccess.expectations) > 0 {
		mmHasReadGroupAccess.mock.t.Fatalf("Some expectations are already set for the GroupAccessProvider.CheckReadGroupAccess method")
	}

	mmHasReadGroupAccess.mock.funcHasReadGroupAccess = f
	mmHasReadGroupAccess.mock.funcHasReadGroupAccessOrigin = minimock.CallerInfo(1)
	return mmHasReadGroupAccess.mock
}

// When sets expectation for the GroupAccessProvider.HasReadGroupAccess which will trigger the result defined by the following
// Then helper
func (mmHasReadGroupAccess *mGroupAccessProviderHasReadGroupAccess) When(ctx context.Context, groupId entity.GroupId) *GroupAccessProviderHasReadGroupAccessExpectation {
	if mmHasReadGroupAccess.mock.funcHasReadGroupAccess != nil {
		mmHasReadGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckReadGroupAccess mock is already set by Set")
	}

	expectation := &GroupAccessProviderHasReadGroupAccessExpectation{
		mock:               mmHasReadGroupAccess.mock,
		params:             &GroupAccessProviderHasReadGroupAccessParams{ctx, groupId},
		expectationOrigins: GroupAccessProviderHasReadGroupAccessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHasReadGroupAccess.expectations = append(mmHasReadGroupAccess.expectations, expectation)
	return expectation
}

// Then sets up GroupAccessProvider.HasReadGroupAccess return parameters for the expectation previously defined by the When method
func (e *GroupAccessProviderHasReadGroupAccessExpectation) Then(b1 bool, err error) *GroupAccessProvider {
	e.results = &GroupAccessProviderHasReadGroupAccessResults{b1, err}
	return e.mock
}

// Times sets number of times GroupAccessProvider.HasReadGroupAccess should be invoked
func (mmHasReadGroupAccess *mGroupAccessProviderHasReadGroupAccess) Times(n uint64) *mGroupAccessProviderHasReadGroupAccess {
	if n == 0 {
		mmHasReadGroupAccess.mock.t.Fatalf("Times of GroupAccessProvider.CheckReadGroupAccess mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHasReadGroupAccess.expectedInvocations, n)
	mmHasReadGroupAccess.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHasReadGroupAccess
}

func (mmHasReadGroupAccess *mGroupAccessProviderHasReadGroupAccess) invocationsDone() bool {
	if len(mmHasReadGroupAccess.expectations) == 0 && mmHasReadGroupAccess.defaultExpectation == nil && mmHasReadGroupAccess.mock.funcHasReadGroupAccess == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHasReadGroupAccess.mock.afterHasReadGroupAccessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHasReadGroupAccess.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HasReadGroupAccess implements mm_service.GroupAccessProvider
func (mmHasReadGroupAccess *GroupAccessProvider) HasReadGroupAccess(ctx context.Context, groupId entity.GroupId) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmHasReadGroupAccess.beforeHasReadGroupAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmHasReadGroupAccess.afterHasReadGroupAccessCounter, 1)

	mmHasReadGroupAccess.t.Helper()

	if mmHasReadGroupAccess.inspectFuncHasReadGroupAccess != nil {
		mmHasReadGroupAccess.inspectFuncHasReadGroupAccess(ctx, groupId)
	}

	mm_params := GroupAccessProviderHasReadGroupAccessParams{ctx, groupId}

	// Record call args
	mmHasReadGroupAccess.HasReadGroupAccessMock.mutex.Lock()
	mmHasReadGroupAccess.HasReadGroupAccessMock.callArgs = append(mmHasReadGroupAccess.HasReadGroupAccessMock.callArgs, &mm_params)
	mmHasReadGroupAccess.HasReadGroupAccessMock.mutex.Unlock()

	for _, e := range mmHasReadGroupAccess.HasReadGroupAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmHasReadGroupAccess.HasReadGroupAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHasReadGroupAccess.HasReadGroupAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmHasReadGroupAccess.HasReadGroupAccessMock.defaultExpectation.params
		mm_want_ptrs := mmHasReadGroupAccess.HasReadGroupAccessMock.defaultExpectation.paramPtrs

		mm_got := GroupAccessProviderHasReadGroupAccessParams{ctx, groupId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHasReadGroupAccess.t.Errorf("GroupAccessProvider.CheckReadGroupAccess got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHasReadGroupAccess.HasReadGroupAccessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.groupId != nil && !minimock.Equal(*mm_want_ptrs.groupId, mm_got.groupId) {
				mmHasReadGroupAccess.t.Errorf("GroupAccessProvider.CheckReadGroupAccess got unexpected parameter groupId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHasReadGroupAccess.HasReadGroupAccessMock.defaultExpectation.expectationOrigins.originGroupId, *mm_want_ptrs.groupId, mm_got.groupId, minimock.Diff(*mm_want_ptrs.groupId, mm_got.groupId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHasReadGroupAccess.t.Errorf("GroupAccessProvider.CheckReadGroupAccess got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHasReadGroupAccess.HasReadGroupAccessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHasReadGroupAccess.HasReadGroupAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmHasReadGroupAccess.t.Fatal("No results are set for the GroupAccessProvider.CheckReadGroupAccess")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmHasReadGroupAccess.funcHasReadGroupAccess != nil {
		return mmHasReadGroupAccess.funcHasReadGroupAccess(ctx, groupId)
	}
	mmHasReadGroupAccess.t.Fatalf("Unexpected call to GroupAccessProvider.CheckReadGroupAccess. %v %v", ctx, groupId)
	return
}

// HasReadGroupAccessAfterCounter returns a count of finished GroupAccessProvider.HasReadGroupAccess invocations
func (mmHasReadGroupAccess *GroupAccessProvider) HasReadGroupAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasReadGroupAccess.afterHasReadGroupAccessCounter)
}

// HasReadGroupAccessBeforeCounter returns a count of GroupAccessProvider.HasReadGroupAccess invocations
func (mmHasReadGroupAccess *GroupAccessProvider) HasReadGroupAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasReadGroupAccess.beforeHasReadGroupAccessCounter)
}

// Calls returns a list of arguments used in each call to GroupAccessProvider.HasReadGroupAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHasReadGroupAccess *mGroupAccessProviderHasReadGroupAccess) Calls() []*GroupAccessProviderHasReadGroupAccessParams {
	mmHasReadGroupAccess.mutex.RLock()

	argCopy := make([]*GroupAccessProviderHasReadGroupAccessParams, len(mmHasReadGroupAccess.callArgs))
	copy(argCopy, mmHasReadGroupAccess.callArgs)

	mmHasReadGroupAccess.mutex.RUnlock()

	return argCopy
}

// MinimockHasReadGroupAccessDone returns true if the count of the HasReadGroupAccess invocations corresponds
// the number of defined expectations
func (m *GroupAccessProvider) MinimockHasReadGroupAccessDone() bool {
	if m.HasReadGroupAccessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HasReadGroupAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HasReadGroupAccessMock.invocationsDone()
}

// MinimockHasReadGroupAccessInspect logs each unmet expectation
func (m *GroupAccessProvider) MinimockHasReadGroupAccessInspect() {
	for _, e := range m.HasReadGroupAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupAccessProvider.CheckReadGroupAccess at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHasReadGroupAccessCounter := mm_atomic.LoadUint64(&m.afterHasReadGroupAccessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HasReadGroupAccessMock.defaultExpectation != nil && afterHasReadGroupAccessCounter < 1 {
		if m.HasReadGroupAccessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupAccessProvider.CheckReadGroupAccess at\n%s", m.HasReadGroupAccessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupAccessProvider.CheckReadGroupAccess at\n%s with params: %#v", m.HasReadGroupAccessMock.defaultExpectation.expectationOrigins.origin, *m.HasReadGroupAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasReadGroupAccess != nil && afterHasReadGroupAccessCounter < 1 {
		m.t.Errorf("Expected call to GroupAccessProvider.CheckReadGroupAccess at\n%s", m.funcHasReadGroupAccessOrigin)
	}

	if !m.HasReadGroupAccessMock.invocationsDone() && afterHasReadGroupAccessCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupAccessProvider.CheckReadGroupAccess at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HasReadGroupAccessMock.expectedInvocations), m.HasReadGroupAccessMock.expectedInvocationsOrigin, afterHasReadGroupAccessCounter)
	}
}

type mGroupAccessProviderHasWriteGroupAccess struct {
	optional           bool
	mock               *GroupAccessProvider
	defaultExpectation *GroupAccessProviderHasWriteGroupAccessExpectation
	expectations       []*GroupAccessProviderHasWriteGroupAccessExpectation

	callArgs []*GroupAccessProviderHasWriteGroupAccessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupAccessProviderHasWriteGroupAccessExpectation specifies expectation struct of the GroupAccessProvider.HasWriteGroupAccess
type GroupAccessProviderHasWriteGroupAccessExpectation struct {
	mock               *GroupAccessProvider
	params             *GroupAccessProviderHasWriteGroupAccessParams
	paramPtrs          *GroupAccessProviderHasWriteGroupAccessParamPtrs
	expectationOrigins GroupAccessProviderHasWriteGroupAccessExpectationOrigins
	results            *GroupAccessProviderHasWriteGroupAccessResults
	returnOrigin       string
	Counter            uint64
}

// GroupAccessProviderHasWriteGroupAccessParams contains parameters of the GroupAccessProvider.HasWriteGroupAccess
type GroupAccessProviderHasWriteGroupAccessParams struct {
	ctx     context.Context
	groupId entity.GroupId
}

// GroupAccessProviderHasWriteGroupAccessParamPtrs contains pointers to parameters of the GroupAccessProvider.HasWriteGroupAccess
type GroupAccessProviderHasWriteGroupAccessParamPtrs struct {
	ctx     *context.Context
	groupId *entity.GroupId
}

// GroupAccessProviderHasWriteGroupAccessResults contains results of the GroupAccessProvider.HasWriteGroupAccess
type GroupAccessProviderHasWriteGroupAccessResults struct {
	b1  bool
	err error
}

// GroupAccessProviderHasWriteGroupAccessOrigins contains origins of expectations of the GroupAccessProvider.HasWriteGroupAccess
type GroupAccessProviderHasWriteGroupAccessExpectationOrigins struct {
	origin        string
	originCtx     string
	originGroupId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHasWriteGroupAccess *mGroupAccessProviderHasWriteGroupAccess) Optional() *mGroupAccessProviderHasWriteGroupAccess {
	mmHasWriteGroupAccess.optional = true
	return mmHasWriteGroupAccess
}

// Expect sets up expected params for GroupAccessProvider.HasWriteGroupAccess
func (mmHasWriteGroupAccess *mGroupAccessProviderHasWriteGroupAccess) Expect(ctx context.Context, groupId entity.GroupId) *mGroupAccessProviderHasWriteGroupAccess {
	if mmHasWriteGroupAccess.mock.funcHasWriteGroupAccess != nil {
		mmHasWriteGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckWriteGroupAccess mock is already set by Set")
	}

	if mmHasWriteGroupAccess.defaultExpectation == nil {
		mmHasWriteGroupAccess.defaultExpectation = &GroupAccessProviderHasWriteGroupAccessExpectation{}
	}

	if mmHasWriteGroupAccess.defaultExpectation.paramPtrs != nil {
		mmHasWriteGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckWriteGroupAccess mock is already set by ExpectParams functions")
	}

	mmHasWriteGroupAccess.defaultExpectation.params = &GroupAccessProviderHasWriteGroupAccessParams{ctx, groupId}
	mmHasWriteGroupAccess.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHasWriteGroupAccess.expectations {
		if minimock.Equal(e.params, mmHasWriteGroupAccess.defaultExpectation.params) {
			mmHasWriteGroupAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHasWriteGroupAccess.defaultExpectation.params)
		}
	}

	return mmHasWriteGroupAccess
}

// ExpectCtxParam1 sets up expected param ctx for GroupAccessProvider.HasWriteGroupAccess
func (mmHasWriteGroupAccess *mGroupAccessProviderHasWriteGroupAccess) ExpectCtxParam1(ctx context.Context) *mGroupAccessProviderHasWriteGroupAccess {
	if mmHasWriteGroupAccess.mock.funcHasWriteGroupAccess != nil {
		mmHasWriteGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckWriteGroupAccess mock is already set by Set")
	}

	if mmHasWriteGroupAccess.defaultExpectation == nil {
		mmHasWriteGroupAccess.defaultExpectation = &GroupAccessProviderHasWriteGroupAccessExpectation{}
	}

	if mmHasWriteGroupAccess.defaultExpectation.params != nil {
		mmHasWriteGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckWriteGroupAccess mock is already set by Expect")
	}

	if mmHasWriteGroupAccess.defaultExpectation.paramPtrs == nil {
		mmHasWriteGroupAccess.defaultExpectation.paramPtrs = &GroupAccessProviderHasWriteGroupAccessParamPtrs{}
	}
	mmHasWriteGroupAccess.defaultExpectation.paramPtrs.ctx = &ctx
	mmHasWriteGroupAccess.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHasWriteGroupAccess
}

// ExpectGroupIdParam2 sets up expected param groupId for GroupAccessProvider.HasWriteGroupAccess
func (mmHasWriteGroupAccess *mGroupAccessProviderHasWriteGroupAccess) ExpectGroupIdParam2(groupId entity.GroupId) *mGroupAccessProviderHasWriteGroupAccess {
	if mmHasWriteGroupAccess.mock.funcHasWriteGroupAccess != nil {
		mmHasWriteGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckWriteGroupAccess mock is already set by Set")
	}

	if mmHasWriteGroupAccess.defaultExpectation == nil {
		mmHasWriteGroupAccess.defaultExpectation = &GroupAccessProviderHasWriteGroupAccessExpectation{}
	}

	if mmHasWriteGroupAccess.defaultExpectation.params != nil {
		mmHasWriteGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckWriteGroupAccess mock is already set by Expect")
	}

	if mmHasWriteGroupAccess.defaultExpectation.paramPtrs == nil {
		mmHasWriteGroupAccess.defaultExpectation.paramPtrs = &GroupAccessProviderHasWriteGroupAccessParamPtrs{}
	}
	mmHasWriteGroupAccess.defaultExpectation.paramPtrs.groupId = &groupId
	mmHasWriteGroupAccess.defaultExpectation.expectationOrigins.originGroupId = minimock.CallerInfo(1)

	return mmHasWriteGroupAccess
}

// Inspect accepts an inspector function that has same arguments as the GroupAccessProvider.HasWriteGroupAccess
func (mmHasWriteGroupAccess *mGroupAccessProviderHasWriteGroupAccess) Inspect(f func(ctx context.Context, groupId entity.GroupId)) *mGroupAccessProviderHasWriteGroupAccess {
	if mmHasWriteGroupAccess.mock.inspectFuncHasWriteGroupAccess != nil {
		mmHasWriteGroupAccess.mock.t.Fatalf("Inspect function is already set for GroupAccessProvider.CheckWriteGroupAccess")
	}

	mmHasWriteGroupAccess.mock.inspectFuncHasWriteGroupAccess = f

	return mmHasWriteGroupAccess
}

// Return sets up results that will be returned by GroupAccessProvider.HasWriteGroupAccess
func (mmHasWriteGroupAccess *mGroupAccessProviderHasWriteGroupAccess) Return(b1 bool, err error) *GroupAccessProvider {
	if mmHasWriteGroupAccess.mock.funcHasWriteGroupAccess != nil {
		mmHasWriteGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckWriteGroupAccess mock is already set by Set")
	}

	if mmHasWriteGroupAccess.defaultExpectation == nil {
		mmHasWriteGroupAccess.defaultExpectation = &GroupAccessProviderHasWriteGroupAccessExpectation{mock: mmHasWriteGroupAccess.mock}
	}
	mmHasWriteGroupAccess.defaultExpectation.results = &GroupAccessProviderHasWriteGroupAccessResults{b1, err}
	mmHasWriteGroupAccess.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHasWriteGroupAccess.mock
}

// Set uses given function f to mock the GroupAccessProvider.HasWriteGroupAccess method
func (mmHasWriteGroupAccess *mGroupAccessProviderHasWriteGroupAccess) Set(f func(ctx context.Context, groupId entity.GroupId) (b1 bool, err error)) *GroupAccessProvider {
	if mmHasWriteGroupAccess.defaultExpectation != nil {
		mmHasWriteGroupAccess.mock.t.Fatalf("Default expectation is already set for the GroupAccessProvider.CheckWriteGroupAccess method")
	}

	if len(mmHasWriteGroupAccess.expectations) > 0 {
		mmHasWriteGroupAccess.mock.t.Fatalf("Some expectations are already set for the GroupAccessProvider.CheckWriteGroupAccess method")
	}

	mmHasWriteGroupAccess.mock.funcHasWriteGroupAccess = f
	mmHasWriteGroupAccess.mock.funcHasWriteGroupAccessOrigin = minimock.CallerInfo(1)
	return mmHasWriteGroupAccess.mock
}

// When sets expectation for the GroupAccessProvider.HasWriteGroupAccess which will trigger the result defined by the following
// Then helper
func (mmHasWriteGroupAccess *mGroupAccessProviderHasWriteGroupAccess) When(ctx context.Context, groupId entity.GroupId) *GroupAccessProviderHasWriteGroupAccessExpectation {
	if mmHasWriteGroupAccess.mock.funcHasWriteGroupAccess != nil {
		mmHasWriteGroupAccess.mock.t.Fatalf("GroupAccessProvider.CheckWriteGroupAccess mock is already set by Set")
	}

	expectation := &GroupAccessProviderHasWriteGroupAccessExpectation{
		mock:               mmHasWriteGroupAccess.mock,
		params:             &GroupAccessProviderHasWriteGroupAccessParams{ctx, groupId},
		expectationOrigins: GroupAccessProviderHasWriteGroupAccessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHasWriteGroupAccess.expectations = append(mmHasWriteGroupAccess.expectations, expectation)
	return expectation
}

// Then sets up GroupAccessProvider.HasWriteGroupAccess return parameters for the expectation previously defined by the When method
func (e *GroupAccessProviderHasWriteGroupAccessExpectation) Then(b1 bool, err error) *GroupAccessProvider {
	e.results = &GroupAccessProviderHasWriteGroupAccessResults{b1, err}
	return e.mock
}

// Times sets number of times GroupAccessProvider.HasWriteGroupAccess should be invoked
func (mmHasWriteGroupAccess *mGroupAccessProviderHasWriteGroupAccess) Times(n uint64) *mGroupAccessProviderHasWriteGroupAccess {
	if n == 0 {
		mmHasWriteGroupAccess.mock.t.Fatalf("Times of GroupAccessProvider.CheckWriteGroupAccess mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHasWriteGroupAccess.expectedInvocations, n)
	mmHasWriteGroupAccess.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHasWriteGroupAccess
}

func (mmHasWriteGroupAccess *mGroupAccessProviderHasWriteGroupAccess) invocationsDone() bool {
	if len(mmHasWriteGroupAccess.expectations) == 0 && mmHasWriteGroupAccess.defaultExpectation == nil && mmHasWriteGroupAccess.mock.funcHasWriteGroupAccess == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHasWriteGroupAccess.mock.afterHasWriteGroupAccessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHasWriteGroupAccess.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HasWriteGroupAccess implements mm_service.GroupAccessProvider
func (mmHasWriteGroupAccess *GroupAccessProvider) HasWriteGroupAccess(ctx context.Context, groupId entity.GroupId) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmHasWriteGroupAccess.beforeHasWriteGroupAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmHasWriteGroupAccess.afterHasWriteGroupAccessCounter, 1)

	mmHasWriteGroupAccess.t.Helper()

	if mmHasWriteGroupAccess.inspectFuncHasWriteGroupAccess != nil {
		mmHasWriteGroupAccess.inspectFuncHasWriteGroupAccess(ctx, groupId)
	}

	mm_params := GroupAccessProviderHasWriteGroupAccessParams{ctx, groupId}

	// Record call args
	mmHasWriteGroupAccess.HasWriteGroupAccessMock.mutex.Lock()
	mmHasWriteGroupAccess.HasWriteGroupAccessMock.callArgs = append(mmHasWriteGroupAccess.HasWriteGroupAccessMock.callArgs, &mm_params)
	mmHasWriteGroupAccess.HasWriteGroupAccessMock.mutex.Unlock()

	for _, e := range mmHasWriteGroupAccess.HasWriteGroupAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmHasWriteGroupAccess.HasWriteGroupAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHasWriteGroupAccess.HasWriteGroupAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmHasWriteGroupAccess.HasWriteGroupAccessMock.defaultExpectation.params
		mm_want_ptrs := mmHasWriteGroupAccess.HasWriteGroupAccessMock.defaultExpectation.paramPtrs

		mm_got := GroupAccessProviderHasWriteGroupAccessParams{ctx, groupId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHasWriteGroupAccess.t.Errorf("GroupAccessProvider.CheckWriteGroupAccess got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHasWriteGroupAccess.HasWriteGroupAccessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.groupId != nil && !minimock.Equal(*mm_want_ptrs.groupId, mm_got.groupId) {
				mmHasWriteGroupAccess.t.Errorf("GroupAccessProvider.CheckWriteGroupAccess got unexpected parameter groupId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHasWriteGroupAccess.HasWriteGroupAccessMock.defaultExpectation.expectationOrigins.originGroupId, *mm_want_ptrs.groupId, mm_got.groupId, minimock.Diff(*mm_want_ptrs.groupId, mm_got.groupId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHasWriteGroupAccess.t.Errorf("GroupAccessProvider.CheckWriteGroupAccess got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHasWriteGroupAccess.HasWriteGroupAccessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHasWriteGroupAccess.HasWriteGroupAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmHasWriteGroupAccess.t.Fatal("No results are set for the GroupAccessProvider.CheckWriteGroupAccess")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmHasWriteGroupAccess.funcHasWriteGroupAccess != nil {
		return mmHasWriteGroupAccess.funcHasWriteGroupAccess(ctx, groupId)
	}
	mmHasWriteGroupAccess.t.Fatalf("Unexpected call to GroupAccessProvider.CheckWriteGroupAccess. %v %v", ctx, groupId)
	return
}

// HasWriteGroupAccessAfterCounter returns a count of finished GroupAccessProvider.HasWriteGroupAccess invocations
func (mmHasWriteGroupAccess *GroupAccessProvider) HasWriteGroupAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasWriteGroupAccess.afterHasWriteGroupAccessCounter)
}

// HasWriteGroupAccessBeforeCounter returns a count of GroupAccessProvider.HasWriteGroupAccess invocations
func (mmHasWriteGroupAccess *GroupAccessProvider) HasWriteGroupAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasWriteGroupAccess.beforeHasWriteGroupAccessCounter)
}

// Calls returns a list of arguments used in each call to GroupAccessProvider.HasWriteGroupAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHasWriteGroupAccess *mGroupAccessProviderHasWriteGroupAccess) Calls() []*GroupAccessProviderHasWriteGroupAccessParams {
	mmHasWriteGroupAccess.mutex.RLock()

	argCopy := make([]*GroupAccessProviderHasWriteGroupAccessParams, len(mmHasWriteGroupAccess.callArgs))
	copy(argCopy, mmHasWriteGroupAccess.callArgs)

	mmHasWriteGroupAccess.mutex.RUnlock()

	return argCopy
}

// MinimockHasWriteGroupAccessDone returns true if the count of the HasWriteGroupAccess invocations corresponds
// the number of defined expectations
func (m *GroupAccessProvider) MinimockHasWriteGroupAccessDone() bool {
	if m.HasWriteGroupAccessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HasWriteGroupAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HasWriteGroupAccessMock.invocationsDone()
}

// MinimockHasWriteGroupAccessInspect logs each unmet expectation
func (m *GroupAccessProvider) MinimockHasWriteGroupAccessInspect() {
	for _, e := range m.HasWriteGroupAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupAccessProvider.CheckWriteGroupAccess at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHasWriteGroupAccessCounter := mm_atomic.LoadUint64(&m.afterHasWriteGroupAccessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HasWriteGroupAccessMock.defaultExpectation != nil && afterHasWriteGroupAccessCounter < 1 {
		if m.HasWriteGroupAccessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupAccessProvider.CheckWriteGroupAccess at\n%s", m.HasWriteGroupAccessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupAccessProvider.CheckWriteGroupAccess at\n%s with params: %#v", m.HasWriteGroupAccessMock.defaultExpectation.expectationOrigins.origin, *m.HasWriteGroupAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasWriteGroupAccess != nil && afterHasWriteGroupAccessCounter < 1 {
		m.t.Errorf("Expected call to GroupAccessProvider.CheckWriteGroupAccess at\n%s", m.funcHasWriteGroupAccessOrigin)
	}

	if !m.HasWriteGroupAccessMock.invocationsDone() && afterHasWriteGroupAccessCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupAccessProvider.CheckWriteGroupAccess at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HasWriteGroupAccessMock.expectedInvocations), m.HasWriteGroupAccessMock.expectedInvocationsOrigin, afterHasWriteGroupAccessCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *GroupAccessProvider) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockHasReadGroupAccessInspect()

			m.MinimockHasWriteGroupAccessInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *GroupAccessProvider) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *GroupAccessProvider) minimockDone() bool {
	done := true
	return done &&
		m.MinimockHasReadGroupAccessDone() &&
		m.MinimockHasWriteGroupAccessDone()
}
